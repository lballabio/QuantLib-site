<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>ObjectHandler: ObjectHandler Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link rel="stylesheet" href="tabs.css">
    <link rel="stylesheet" href="ql.css">
    <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon">
    <link rel="icon" href="images/favicon.ico" type="image/x-icon">
</head>
<body>
    <div id='wrapper'>
        <div id='header'>
        <div id='floatleft'><a class="imglink" href="index.html"><img src="images/logo_oh.jpg" width="180" height="72" border="0" alt="ObjectHandler Logo"/></a></div>
        <div id='floatright'><a class="imglink" href="http://quantlib.org"><img src="images/logo_ql.jpg" width="130" height="82" border="0" alt="QuantLib Logo"/></a></div>
        </div>
        <div id='content'>
            <div id='col-left'>
            <div id="version">Version 1.14.0</div>
                <div id='sidebar'>
<ul>
<li class="menuheader"><a href="index.html">Home</a></li>
<li><a href="installation.html">Installation</a></li>
<li><a href="design.html">Design</a></li>
<li><a href="history.html">History</a></li>
<li><a href="license.html">License</a></li>
<li><a href="people.html">People</a></li>
<li class="menuheader"><a href="functional.html">Functional<br>Documentation</a></li>
<li><a href="manual.html">Manual</a></li>
<li><a href="allfunctions.html">Functions</a></li>
<li><a href="categories.html">Categories</a></li>
<li class="menuheader"><a href="technical.html">Technical<br>Documentation</a></li>
<li><a href="annotated.html">Classes</a></li>
<li><a href="hierarchy.html">Hierarchy</a></li>
<li><a href="files.html">Files</a></li>
<li><a href="examples.html">Examples</a></li>
</ul>
                </div>
<div class="logo">
<div class="vspace"></div>
<a href="http://www.reposit.be" id="reposit_logo"></a>
<div class="vspace"></div>
<a class="imglink" href="http://sourceforge.net"><img src="images/sflogo.png" width="88" height="31" border="0" alt="SourceForge.net Logo"/></a>
<div class="vspace"></div>
</div>
            </div>
            <div id='col-right'>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ObjectHandler Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="namespace_object_handler.html" title="ObjectHandler. ">ObjectHandler</a>.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_object_handler_1_1matrix"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_object_handler_1_1matrix.html">matrix</a></td></tr>
<tr class="memdesc:namespace_object_handler_1_1matrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function to convert a matrix from type <a class="el" href="class_object_handler_1_1property__t.html" title="A value of variant type. ">property_t</a> to type value_t. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_object_handler_1_1vector"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_object_handler_1_1vector.html">vector</a></td></tr>
<tr class="memdesc:namespace_object_handler_1_1vector"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function to convert a vector from type <a class="el" href="class_object_handler_1_1property__t.html" title="A value of variant type. ">property_t</a> to type value_t. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_object_handler_1_1_caller_dimensions.html">CallerDimensions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The dimensions of the calling range.  <a href="struct_object_handler_1_1_caller_dimensions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_object_handler_1_1_caller_type.html">CallerType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The environment which called the function that is currently running.  <a href="struct_object_handler_1_1_caller_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_handler_1_1_calling_range.html">CallingRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processing for the host cell of an <a class="el" href="class_object_handler_1_1_object.html" title="Interface for Objects to be stored in the ObjectHandler Repository. ">Object</a>.  <a href="class_object_handler_1_1_calling_range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_handler_1_1_coerce.html">Coerce</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class in support of datatype coercion.  <a href="class_object_handler_1_1_coerce.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_handler_1_1_configuration.html">Configuration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global configuration information specific to the Excel session.  <a href="class_object_handler_1_1_configuration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_handler_1_1_convert_oper.html">ConvertOper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform datatype conversions of OPERs.  <a href="class_object_handler_1_1_convert_oper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_handler_1_1_create.html">Create</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the enumerated type associated with a string.  <a href="class_object_handler_1_1_create.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_handler_1_1_default_processor.html">DefaultProcessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default behavior for post serialization processing of an <a class="el" href="class_object_handler_1_1_object.html" title="Interface for Objects to be stored in the ObjectHandler Repository. ">Object</a>.  <a href="class_object_handler_1_1_default_processor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_object_handler_1_1empty__property__tag.html">empty_property_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Placeholder for a null value.  <a href="struct_object_handler_1_1empty__property__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_handler_1_1_enum_class_registry.html">EnumClassRegistry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concrete instantiation of the <a class="el" href="class_object_handler_1_1_registry.html" title="A registry of enumerated types and classes. ">Registry</a> class, for enumerated classes.  <a href="class_object_handler_1_1_enum_class_registry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_handler_1_1_enum_pair_registry.html">EnumPairRegistry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concrete instantiation of the <a class="el" href="class_object_handler_1_1_registry.html" title="A registry of enumerated types and classes. ">Registry</a> class, for "pairs".  <a href="class_object_handler_1_1_enum_pair_registry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_handler_1_1_enum_type_registry.html">EnumTypeRegistry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concrete instantiation of the <a class="el" href="class_object_handler_1_1_registry.html" title="A registry of enumerated types and classes. ">Registry</a> class, for enumerated types.  <a href="class_object_handler_1_1_enum_type_registry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_handler_1_1_exception.html">Exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple implementation of an exception.  <a href="class_object_handler_1_1_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_handler_1_1_function_call.html">FunctionCall</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_object_handler_1_1_singleton.html" title="Basic support for the singleton pattern. ">Singleton</a> encapsulating state relating to Excel function call.  <a href="class_object_handler_1_1_function_call.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_handler_1_1_group.html">Group</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A collection of Objects.  <a href="class_object_handler_1_1_group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_handler_1_1_library_object.html">LibraryObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Customizes the <a class="el" href="class_object_handler_1_1_object.html" title="Interface for Objects to be stored in the ObjectHandler Repository. ">Object</a> class for most typical uses.  <a href="class_object_handler_1_1_library_object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_handler_1_1_logger.html">Logger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for the logging framework.  <a href="class_object_handler_1_1_logger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_object_handler_1_1_loop_iteration.html">LoopIteration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute one iteration of the loop function.  <a href="struct_object_handler_1_1_loop_iteration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_object_handler_1_1_loop_iteration_3_01_loop_function_00_01_input_type_00_01void_01_4.html">LoopIteration&lt; LoopFunction, InputType, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialization for <a class="el" href="struct_object_handler_1_1_loop_iteration.html" title="Execute one iteration of the loop function. ">LoopIteration</a> where return type is void.  <a href="struct_object_handler_1_1_loop_iteration_3_01_loop_function_00_01_input_type_00_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_handler_1_1my__iless.html">my_iless</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::string specialized case insensitive version of less  <a href="class_object_handler_1_1my__iless.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_handler_1_1_object.html">Object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for Objects to be stored in the <a class="el" href="namespace_object_handler.html" title="ObjectHandler. ">ObjectHandler</a> <a class="el" href="class_object_handler_1_1_repository.html" title="Maintain a store of Objects. ">Repository</a>.  <a href="class_object_handler_1_1_object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_handler_1_1_object_wrapper.html">ObjectWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container to ensure that <a class="el" href="class_object_handler_1_1_object.html" title="Interface for Objects to be stored in the ObjectHandler Repository. ">Object</a> references are updated.  <a href="class_object_handler_1_1_object_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_handler_1_1_object_wrapper_x_l.html">ObjectWrapperXL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Customization of the <a class="el" href="class_object_handler_1_1_object_wrapper.html" title="Container to ensure that Object references are updated. ">ObjectWrapper</a> class for the Excel platform.  <a href="class_object_handler_1_1_object_wrapper_x_l.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_handler_1_1_observable.html">Observable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_object_handler_1_1_object.html" title="Interface for Objects to be stored in the ObjectHandler Repository. ">Object</a> that notifies its changes to a set of observers.  <a href="class_object_handler_1_1_observable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_handler_1_1_observer.html">Observer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_object_handler_1_1_object.html" title="Interface for Objects to be stored in the ObjectHandler Repository. ">Object</a> that gets notified when a given observable changes.  <a href="class_object_handler_1_1_observer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_handler_1_1_processor.html">Processor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore the state of an <a class="el" href="class_object_handler_1_1_object.html" title="Interface for Objects to be stored in the ObjectHandler Repository. ">Object</a> after deserialization.  <a href="class_object_handler_1_1_processor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_handler_1_1_processor_factory.html">ProcessorFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manage all of the <a class="el" href="class_object_handler_1_1_processor.html" title="Restore the state of an Object after deserialization. ">Processor</a> objects which are defined for this environment.  <a href="class_object_handler_1_1_processor_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_handler_1_1property__t.html">property_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A value of variant type.  <a href="class_object_handler_1_1property__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_handler_1_1_range.html">Range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for a matrix of doubles.  <a href="class_object_handler_1_1_range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_handler_1_1_range_reference.html">RangeReference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class for parsing range references in string format.  <a href="class_object_handler_1_1_range_reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_handler_1_1_registry.html">Registry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A registry of enumerated types and classes.  <a href="class_object_handler_1_1_registry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_handler_1_1_registry_manager.html">RegistryManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manage access to an Enumeration <a class="el" href="class_object_handler_1_1_registry.html" title="A registry of enumerated types and classes. ">Registry</a>.  <a href="class_object_handler_1_1_registry_manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_handler_1_1_repository.html">Repository</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maintain a store of Objects.  <a href="class_object_handler_1_1_repository.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_handler_1_1_repository_x_l.html">RepositoryXL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Excel-specific enhancements to the <a class="el" href="class_object_handler_1_1_repository.html" title="Maintain a store of Objects. ">Repository</a> class.  <a href="class_object_handler_1_1_repository_x_l.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_handler_1_1_serialization_factory.html">SerializationFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_object_handler_1_1_singleton.html" title="Basic support for the singleton pattern. ">Singleton</a> wrapping the boost::serialization interface.  <a href="class_object_handler_1_1_serialization_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_handler_1_1_singleton.html">Singleton</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic support for the singleton pattern.  <a href="class_object_handler_1_1_singleton.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_handler_1_1_value_object.html">ValueObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capture the values of the arguments passed to the <a class="el" href="class_object_handler_1_1_object.html" title="Interface for Objects to be stored in the ObjectHandler Repository. ">Object</a> constructor.  <a href="class_object_handler_1_1_value_object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_object_handler_1_1_x.html">X</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_handler_1_1_xloper.html">Xloper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform RAII for Excel's XLOPER datatype.  <a href="class_object_handler_1_1_xloper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a892c9f9f6c17eb74c345a4be752ceea2"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#a892c9f9f6c17eb74c345a4be752ceea2">KeyPair</a></td></tr>
<tr class="memdesc:a892c9f9f6c17eb74c345a4be752ceea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pair of strings.  <a href="#a892c9f9f6c17eb74c345a4be752ceea2">More...</a><br /></td></tr>
<tr class="separator:a892c9f9f6c17eb74c345a4be752ceea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee09a3eec5b80b433884eb75650013c"><td class="memItemLeft" align="right" valign="top"><a id="a3ee09a3eec5b80b433884eb75650013c"></a>
typedef boost::_bi::bind_t&lt; <a class="el" href="class_object_handler_1_1property__t.html">ObjectHandler::property_t</a>, boost::_mfi::cmf1&lt; <a class="el" href="class_object_handler_1_1property__t.html">ObjectHandler::property_t</a>, <a class="el" href="class_object_handler_1_1_object.html">ObjectHandler::Object</a>, const std::string &amp; &gt;, boost::_bi::list2&lt; boost::_bi::value&lt; boost::shared_ptr&lt; <a class="el" href="class_object_handler_1_1_object.html">ObjectHandler::Object</a> &gt; &gt;, boost::arg&lt; 1 &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ohObjectPropertyValuesBind</b></td></tr>
<tr class="separator:a3ee09a3eec5b80b433884eb75650013c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ede3d3f0d2031bd8ec87ada71f5bb01"><td class="memItemLeft" align="right" valign="top"><a id="a4ede3d3f0d2031bd8ec87ada71f5bb01"></a>
typedef <a class="el" href="class_object_handler_1_1property__t.html">ObjectHandler::property_t</a>(ObjectHandler::Object::*&#160;</td><td class="memItemRight" valign="bottom"><b>ohObjectPropertyValuesSignature</b>) (const std::string &amp;) const</td></tr>
<tr class="separator:a4ede3d3f0d2031bd8ec87ada71f5bb01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b6078ec4167287916fd00ae1a52bb3a"><td class="memItemLeft" align="right" valign="top"><a id="a4b6078ec4167287916fd00ae1a52bb3a"></a>
typedef std::pair&lt; std::string, boost::shared_ptr&lt; <a class="el" href="class_object_handler_1_1_object.html">Object</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>StrObjectPair</b></td></tr>
<tr class="separator:a4b6078ec4167287916fd00ae1a52bb3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8413b1bbd78b6d9a18b6a468e174ce2f"><td class="memItemLeft" align="right" valign="top"><a id="a8413b1bbd78b6d9a18b6a468e174ce2f"></a>
typedef std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Category</b></td></tr>
<tr class="separator:a8413b1bbd78b6d9a18b6a468e174ce2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab475d083a9e720837afd76581b274259"><td class="memItemLeft" align="right" valign="top"><a id="ab475d083a9e720837afd76581b274259"></a>
typedef std::list&lt; StrObjectPair &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>HandlesList</b></td></tr>
<tr class="separator:ab475d083a9e720837afd76581b274259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe51dd10e67ae558018fa85150e449e0"><td class="memItemLeft" align="right" valign="top"><a id="abe51dd10e67ae558018fa85150e449e0"></a>
typedef boost::shared_ptr&lt; <a class="el" href="class_object_handler_1_1_processor.html">Processor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ProcessorPtr</b></td></tr>
<tr class="separator:abe51dd10e67ae558018fa85150e449e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3d0d68c0fd56873f0c3c83ca547ffc"><td class="memItemLeft" align="right" valign="top"><a id="a0c3d0d68c0fd56873f0c3c83ca547ffc"></a>
typedef boost::make_recursive_variant&lt; <a class="el" href="struct_object_handler_1_1empty__property__tag.html">empty_property_tag</a>, bool, int, std::string, long, double, std::vector&lt; boost::recursive_variant_ &gt; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#a0c3d0d68c0fd56873f0c3c83ca547ffc">property_base</a></td></tr>
<tr class="memdesc:a0c3d0d68c0fd56873f0c3c83ca547ffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The underlying types supported by <a class="el" href="class_object_handler_1_1property__t.html" title="A value of variant type. ">property_t</a>. <br /></td></tr>
<tr class="separator:a0c3d0d68c0fd56873f0c3c83ca547ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0e7b5a48f78dd6b40bf3b39f43cbbee4"><td class="memTemplParams" colspan="2"><a id="a0e7b5a48f78dd6b40bf3b39f43cbbee4"></a>
template&lt;class ObjectClass &gt; </td></tr>
<tr class="memitem:a0e7b5a48f78dd6b40bf3b39f43cbbee4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; boost::shared_ptr&lt; ObjectClass &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#a0e7b5a48f78dd6b40bf3b39f43cbbee4">getObjectVector</a> (const std::vector&lt; std::string &gt; &amp;objectIDs, const int &amp;nestingLevel=0, bool includeGroups=false)</td></tr>
<tr class="memdesc:a0e7b5a48f78dd6b40bf3b39f43cbbee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of <a class="el" href="class_object_handler_1_1_object.html" title="Interface for Objects to be stored in the ObjectHandler Repository. ">Object</a> IDs to a vector of objects. <br /></td></tr>
<tr class="separator:a0e7b5a48f78dd6b40bf3b39f43cbbee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6306327d719669e8f4c106644d7afe"><td class="memTemplParams" colspan="2"><a id="aff6306327d719669e8f4c106644d7afe"></a>
template&lt;class ObjectClass , class LibraryClass &gt; </td></tr>
<tr class="memitem:aff6306327d719669e8f4c106644d7afe"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; boost::shared_ptr&lt; LibraryClass &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#aff6306327d719669e8f4c106644d7afe">getLibraryObjectVector</a> (const std::vector&lt; std::string &gt; &amp;objectIDs, const int &amp;nestingLevel=0)</td></tr>
<tr class="memdesc:aff6306327d719669e8f4c106644d7afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of <a class="el" href="class_object_handler_1_1_object.html" title="Interface for Objects to be stored in the ObjectHandler Repository. ">Object</a> IDs to a vector of library objects. <br /></td></tr>
<tr class="separator:aff6306327d719669e8f4c106644d7afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae083eef16233065b440aa9eba41ef831"><td class="memItemLeft" align="right" valign="top"><a id="ae083eef16233065b440aa9eba41ef831"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#ae083eef16233065b440aa9eba41ef831">uppercase</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:ae083eef16233065b440aa9eba41ef831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a std::string to uppercase. <br /></td></tr>
<tr class="separator:ae083eef16233065b440aa9eba41ef831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e3d18b84c06930a36b09ef5068e16c"><td class="memItemLeft" align="right" valign="top"><a id="a50e3d18b84c06930a36b09ef5068e16c"></a>
<a class="el" href="namespace_object_handler.html#a892c9f9f6c17eb74c345a4be752ceea2">KeyPair</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#a50e3d18b84c06930a36b09ef5068e16c">uppercase</a> (const <a class="el" href="namespace_object_handler.html#a892c9f9f6c17eb74c345a4be752ceea2">KeyPair</a> &amp;s)</td></tr>
<tr class="memdesc:a50e3d18b84c06930a36b09ef5068e16c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a KeyPair to uppercase. <br /></td></tr>
<tr class="separator:a50e3d18b84c06930a36b09ef5068e16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ae80032a1c84d734a3e9f6e03241f2"><td class="memItemLeft" align="right" valign="top"><a id="ae7ae80032a1c84d734a3e9f6e03241f2"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#ae7ae80032a1c84d734a3e9f6e03241f2">operator&lt;&lt;</a> (std::ostream &amp;left, const <a class="el" href="namespace_object_handler.html#a892c9f9f6c17eb74c345a4be752ceea2">KeyPair</a> &amp;right)</td></tr>
<tr class="memdesc:ae7ae80032a1c84d734a3e9f6e03241f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a KeyPair to the given stream. <br /></td></tr>
<tr class="separator:ae7ae80032a1c84d734a3e9f6e03241f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecbd6370bdce1c4a838cd8b501389c45"><td class="memTemplParams" colspan="2"><a id="aecbd6370bdce1c4a838cd8b501389c45"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aecbd6370bdce1c4a838cd8b501389c45"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#aecbd6370bdce1c4a838cd8b501389c45">vectorStringToEnum</a> (const std::vector&lt; std::string &gt; ids, const std::string &amp;paramName)</td></tr>
<tr class="memdesc:aecbd6370bdce1c4a838cd8b501389c45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a list of strings into the associated enumerations. <br /></td></tr>
<tr class="separator:aecbd6370bdce1c4a838cd8b501389c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c906c59e4f399a366f65a67516fe691"><td class="memItemLeft" align="right" valign="top"><a id="a2c906c59e4f399a366f65a67516fe691"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#a2c906c59e4f399a366f65a67516fe691">operator&lt;&lt;</a> (std::ostream &amp;out, const boost::shared_ptr&lt; <a class="el" href="class_object_handler_1_1_object.html">Object</a> &gt; &amp;object)</td></tr>
<tr class="memdesc:a2c906c59e4f399a366f65a67516fe691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log the given <a class="el" href="class_object_handler_1_1_object.html" title="Interface for Objects to be stored in the ObjectHandler Repository. ">Object</a> to the given stream. <br /></td></tr>
<tr class="separator:a2c906c59e4f399a366f65a67516fe691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43fd6f403c67c1d43564b7e20e949170"><td class="memItemLeft" align="right" valign="top"><a id="a43fd6f403c67c1d43564b7e20e949170"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#a43fd6f403c67c1d43564b7e20e949170">operator&lt;&lt;</a> (std::ostream &amp;out, const boost::shared_ptr&lt; <a class="el" href="class_object_handler_1_1_object_wrapper.html">ObjectWrapper</a> &gt; &amp;ow)</td></tr>
<tr class="memdesc:a43fd6f403c67c1d43564b7e20e949170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log the given <a class="el" href="class_object_handler_1_1_object_wrapper.html" title="Container to ensure that Object references are updated. ">ObjectWrapper</a> to the given stream. <br /></td></tr>
<tr class="separator:a43fd6f403c67c1d43564b7e20e949170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05ce69199efa2ab079a3eaacbd20e55"><td class="memItemLeft" align="right" valign="top"><a id="af05ce69199efa2ab079a3eaacbd20e55"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#af05ce69199efa2ab079a3eaacbd20e55">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="class_object_handler_1_1property__t.html">property_t</a> &amp;p)</td></tr>
<tr class="memdesc:af05ce69199efa2ab079a3eaacbd20e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log the given <a class="el" href="class_object_handler_1_1property__t.html" title="A value of variant type. ">property_t</a> value to the given stream. <br /></td></tr>
<tr class="separator:af05ce69199efa2ab079a3eaacbd20e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672d134453bb9b41885955a531617b3e"><td class="memItemLeft" align="right" valign="top"><a id="a672d134453bb9b41885955a531617b3e"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, const boost::shared_ptr&lt; <a class="el" href="class_object_handler_1_1_calling_range.html">CallingRange</a> &gt; &amp;)</td></tr>
<tr class="separator:a672d134453bb9b41885955a531617b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa967cea84d19f8b130cee2a24655a3"><td class="memTemplParams" colspan="2"><a id="afaa967cea84d19f8b130cee2a24655a3"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:afaa967cea84d19f8b130cee2a24655a3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#afaa967cea84d19f8b130cee2a24655a3">matrixToOper</a> (const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;vv, OPER &amp;xMatrix)</td></tr>
<tr class="memdesc:afaa967cea84d19f8b130cee2a24655a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert type std::vector&lt;std::vector&lt;T&gt; &gt; to an Excel OPER. <br /></td></tr>
<tr class="separator:afaa967cea84d19f8b130cee2a24655a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0fd2f07cce26c0ebc1fc49b886a6e9f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa0fd2f07cce26c0ebc1fc49b886a6e9f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#aa0fd2f07cce26c0ebc1fc49b886a6e9f">operToMatrix</a> (const OPER &amp;xMatrix, const std::string &amp;paramName)</td></tr>
<tr class="memdesc:aa0fd2f07cce26c0ebc1fc49b886a6e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template wrapper for operToMatrixImpl.  <a href="#aa0fd2f07cce26c0ebc1fc49b886a6e9f">More...</a><br /></td></tr>
<tr class="separator:aa0fd2f07cce26c0ebc1fc49b886a6e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad4f6e7e939a7533e0af778cf178c454"><td class="memTemplParams" colspan="2"><a id="aad4f6e7e939a7533e0af778cf178c454"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aad4f6e7e939a7533e0af778cf178c454"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#aad4f6e7e939a7533e0af778cf178c454">operToMatrixImpl</a> (const <a class="el" href="class_object_handler_1_1_convert_oper.html">ConvertOper</a> &amp;xMatrix, const std::string &amp;paramName)</td></tr>
<tr class="memdesc:aad4f6e7e939a7533e0af778cf178c454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a value of type <a class="el" href="class_object_handler_1_1_convert_oper.html" title="Perform datatype conversions of OPERs. ">ConvertOper</a> to a matrix. <br /></td></tr>
<tr class="separator:aad4f6e7e939a7533e0af778cf178c454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3abe79c3c49e4b0197634e8a161b509"><td class="memTemplParams" colspan="2"><a id="ad3abe79c3c49e4b0197634e8a161b509"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad3abe79c3c49e4b0197634e8a161b509"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#ad3abe79c3c49e4b0197634e8a161b509">fpToMatrix</a> (const FP &amp;fpMatrix)</td></tr>
<tr class="memdesc:ad3abe79c3c49e4b0197634e8a161b509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an Excel FP to type std::vector&lt;std::vector&lt;T&gt; &gt;. <br /></td></tr>
<tr class="separator:ad3abe79c3c49e4b0197634e8a161b509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54138a8b40b745c8fb13cb52faa8ef3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac54138a8b40b745c8fb13cb52faa8ef3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#ac54138a8b40b745c8fb13cb52faa8ef3">operToVector</a> (const OPER &amp;xVector, const std::string &amp;paramName)</td></tr>
<tr class="memdesc:ac54138a8b40b745c8fb13cb52faa8ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template wrapper for operToVectorImpl.  <a href="#ac54138a8b40b745c8fb13cb52faa8ef3">More...</a><br /></td></tr>
<tr class="separator:ac54138a8b40b745c8fb13cb52faa8ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9375d8dc71301817d2a5b4f67653b492"><td class="memTemplParams" colspan="2">template&lt;class LibraryClass , class ObjectClass &gt; </td></tr>
<tr class="memitem:a9375d8dc71301817d2a5b4f67653b492"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; boost::shared_ptr&lt; LibraryClass &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#a9375d8dc71301817d2a5b4f67653b492">operToObjectVector</a> (const OPER &amp;xVector, const std::string &amp;paramName)</td></tr>
<tr class="memdesc:a9375d8dc71301817d2a5b4f67653b492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template wrapper for operToVectorImpl.  <a href="#a9375d8dc71301817d2a5b4f67653b492">More...</a><br /></td></tr>
<tr class="separator:a9375d8dc71301817d2a5b4f67653b492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef88be4305f729c8917f409b8f39c42"><td class="memTemplParams" colspan="2"><a id="a8ef88be4305f729c8917f409b8f39c42"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a8ef88be4305f729c8917f409b8f39c42"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#a8ef88be4305f729c8917f409b8f39c42">operToVectorImpl</a> (const <a class="el" href="class_object_handler_1_1_convert_oper.html">ConvertOper</a> &amp;xVector, const std::string &amp;paramName)</td></tr>
<tr class="memdesc:a8ef88be4305f729c8917f409b8f39c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a value of type <a class="el" href="class_object_handler_1_1_convert_oper.html" title="Perform datatype conversions of OPERs. ">ConvertOper</a> to a vector. <br /></td></tr>
<tr class="separator:a8ef88be4305f729c8917f409b8f39c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93060963ce8d948bba1da8a0d9137996"><td class="memTemplParams" colspan="2"><a id="a93060963ce8d948bba1da8a0d9137996"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a93060963ce8d948bba1da8a0d9137996"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#a93060963ce8d948bba1da8a0d9137996">fpToVector</a> (const FP &amp;fpVector)</td></tr>
<tr class="memdesc:a93060963ce8d948bba1da8a0d9137996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an Excel FP to a std::vector of type T. <br /></td></tr>
<tr class="separator:a93060963ce8d948bba1da8a0d9137996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16faeb6b243fcba7aceedf60fb6502bc"><td class="memItemLeft" align="right" valign="top"><a id="a16faeb6b243fcba7aceedf60fb6502bc"></a>
DLL_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#a16faeb6b243fcba7aceedf60fb6502bc">scalarToOper</a> (const int &amp;value, OPER &amp;xInt, bool expandVector=true)</td></tr>
<tr class="memdesc:a16faeb6b243fcba7aceedf60fb6502bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a int to an OPER. <br /></td></tr>
<tr class="separator:a16faeb6b243fcba7aceedf60fb6502bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a1c6a4f62219ae8f3fff692e71c9dc"><td class="memItemLeft" align="right" valign="top"><a id="aa0a1c6a4f62219ae8f3fff692e71c9dc"></a>
DLL_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#aa0a1c6a4f62219ae8f3fff692e71c9dc">scalarToOper</a> (const long &amp;value, OPER &amp;xLong, bool expandVector=true)</td></tr>
<tr class="memdesc:aa0a1c6a4f62219ae8f3fff692e71c9dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a long to an OPER. <br /></td></tr>
<tr class="separator:aa0a1c6a4f62219ae8f3fff692e71c9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35411d9d5e0a45cf29f77ce54afd2a82"><td class="memItemLeft" align="right" valign="top"><a id="a35411d9d5e0a45cf29f77ce54afd2a82"></a>
DLL_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#a35411d9d5e0a45cf29f77ce54afd2a82">scalarToOper</a> (const double &amp;value, OPER &amp;xDouble, bool expandVector=true)</td></tr>
<tr class="memdesc:a35411d9d5e0a45cf29f77ce54afd2a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a double to an OPER. <br /></td></tr>
<tr class="separator:a35411d9d5e0a45cf29f77ce54afd2a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7abfcdd7ee2bc7302092d1a36507b873"><td class="memItemLeft" align="right" valign="top"><a id="a7abfcdd7ee2bc7302092d1a36507b873"></a>
DLL_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#a7abfcdd7ee2bc7302092d1a36507b873">scalarToOper</a> (const bool &amp;value, OPER &amp;xBoolean, bool expandVector=true)</td></tr>
<tr class="memdesc:a7abfcdd7ee2bc7302092d1a36507b873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a bool to an OPER. <br /></td></tr>
<tr class="separator:a7abfcdd7ee2bc7302092d1a36507b873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad2e25be1afaf5e71c2c50b6451724e"><td class="memItemLeft" align="right" valign="top"><a id="aaad2e25be1afaf5e71c2c50b6451724e"></a>
DLL_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#aaad2e25be1afaf5e71c2c50b6451724e">scalarToOper</a> (const char *value, OPER &amp;xChar, bool expandVector=true)</td></tr>
<tr class="memdesc:aaad2e25be1afaf5e71c2c50b6451724e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a char * to an OPER. <br /></td></tr>
<tr class="separator:aaad2e25be1afaf5e71c2c50b6451724e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b50aed61c20b16d7a8de20b0a8c3f4"><td class="memItemLeft" align="right" valign="top"><a id="a30b50aed61c20b16d7a8de20b0a8c3f4"></a>
DLL_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#a30b50aed61c20b16d7a8de20b0a8c3f4">scalarToOper</a> (const std::string &amp;value, OPER &amp;xString, bool expandVector=true)</td></tr>
<tr class="memdesc:a30b50aed61c20b16d7a8de20b0a8c3f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to an OPER. <br /></td></tr>
<tr class="separator:a30b50aed61c20b16d7a8de20b0a8c3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862552ae5dc8ceecca178671f99bfab7"><td class="memItemLeft" align="right" valign="top"><a id="a862552ae5dc8ceecca178671f99bfab7"></a>
DLL_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#a862552ae5dc8ceecca178671f99bfab7">scalarToOper</a> (const <a class="el" href="class_object_handler_1_1property__t.html">property_t</a> &amp;value, OPER &amp;xAny, bool expandVector=true)</td></tr>
<tr class="memdesc:a862552ae5dc8ceecca178671f99bfab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <a class="el" href="class_object_handler_1_1property__t.html" title="A value of variant type. ">property_t</a> to an OPER. <br /></td></tr>
<tr class="separator:a862552ae5dc8ceecca178671f99bfab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312efa7a058c4ca5a9888aa066341214"><td class="memItemLeft" align="right" valign="top"><a id="a312efa7a058c4ca5a9888aa066341214"></a>
DLL_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#a312efa7a058c4ca5a9888aa066341214">validateRange</a> (const OPER *xRange, const std::string &amp;name)</td></tr>
<tr class="memdesc:a312efa7a058c4ca5a9888aa066341214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the given range contains an error value. <br /></td></tr>
<tr class="separator:a312efa7a058c4ca5a9888aa066341214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749fc7e3e73be55b2ef518c734ee0d8a"><td class="memItemLeft" align="right" valign="top">DLL_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#a749fc7e3e73be55b2ef518c734ee0d8a">stringToChar</a> (const std::string &amp;, char *)</td></tr>
<tr class="memdesc:a749fc7e3e73be55b2ef518c734ee0d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the std::string to the char*.  <a href="#a749fc7e3e73be55b2ef518c734ee0d8a">More...</a><br /></td></tr>
<tr class="separator:a749fc7e3e73be55b2ef518c734ee0d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bbd00bac5e532993204d901a7be9f8d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3bbd00bac5e532993204d901a7be9f8d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#a3bbd00bac5e532993204d901a7be9f8d">vectorToOper</a> (const std::vector&lt; T &gt; &amp;v, OPER &amp;xVector)</td></tr>
<tr class="memdesc:a3bbd00bac5e532993204d901a7be9f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for the other vectorToOper.  <a href="#a3bbd00bac5e532993204d901a7be9f8d">More...</a><br /></td></tr>
<tr class="separator:a3bbd00bac5e532993204d901a7be9f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b3eda3d2c8bf3547f23fb5b6ce2c37a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3b3eda3d2c8bf3547f23fb5b6ce2c37a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#a3b3eda3d2c8bf3547f23fb5b6ce2c37a">vectorToOper</a> (T begin, T end, OPER &amp;xVector)</td></tr>
<tr class="memdesc:a3b3eda3d2c8bf3547f23fb5b6ce2c37a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert type std::vector&lt;T&gt; to an Excel OPER.  <a href="#a3b3eda3d2c8bf3547f23fb5b6ce2c37a">More...</a><br /></td></tr>
<tr class="separator:a3b3eda3d2c8bf3547f23fb5b6ce2c37a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76189934982cb92995457b8acbc51b19"><td class="memTemplParams" colspan="2"><a id="a76189934982cb92995457b8acbc51b19"></a>
template&lt;class LoopFunction , class InputType , class OutputType &gt; </td></tr>
<tr class="memitem:a76189934982cb92995457b8acbc51b19"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#a76189934982cb92995457b8acbc51b19">loop</a> (const boost::shared_ptr&lt; <a class="el" href="class_object_handler_1_1_function_call.html">FunctionCall</a> &gt; &amp;functionCall, LoopFunction &amp;loopFunction, OPER *xIn, XLOPER &amp;xOut)</td></tr>
<tr class="memdesc:a76189934982cb92995457b8acbc51b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the contained function once for each item in the input vector. <br /></td></tr>
<tr class="separator:a76189934982cb92995457b8acbc51b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62838c02e18e9306463f31d7fa1e01b"><td class="memItemLeft" align="right" valign="top"><a id="aa62838c02e18e9306463f31d7fa1e01b"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, const <a class="el" href="class_object_handler_1_1_range_reference.html">RangeReference</a> &amp;)</td></tr>
<tr class="separator:aa62838c02e18e9306463f31d7fa1e01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">convert2</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The functions in this file are used by addin functions to convert their inputs into types recognized by the underlying library.</p>
<p>All of these functions are implemented as overrides of template function "convert2".</p>
<p>The reason that these functions are called "convert2" is because they replace an old function "convert" which has now been deleted.</p>
<p>These functions operate on an input value of type container_t. </p><ul>
<li>On C++, container_t is a variant. </li>
<li>On Excel, container_t is an XLOPER. </li>
</ul>
</div></td></tr>
<tr class="memitem:a3de2e369a7c84be4b0fc99a6ab413ec9"><td class="memTemplParams" colspan="2">template&lt;class value_t , class container_t &gt; </td></tr>
<tr class="memitem:a3de2e369a7c84be4b0fc99a6ab413ec9"><td class="memTemplItemLeft" align="right" valign="top">value_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#a3de2e369a7c84be4b0fc99a6ab413ec9">convert2</a> (const container_t &amp;c)</td></tr>
<tr class="memdesc:a3de2e369a7c84be4b0fc99a6ab413ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the input value from type container_t to type value_t.  <a href="#a3de2e369a7c84be4b0fc99a6ab413ec9">More...</a><br /></td></tr>
<tr class="separator:a3de2e369a7c84be4b0fc99a6ab413ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a04a9d2103e27f833a9db2b6479ed5f"><td class="memTemplParams" colspan="2">template&lt;class value_t , class container_t &gt; </td></tr>
<tr class="memitem:a2a04a9d2103e27f833a9db2b6479ed5f"><td class="memTemplItemLeft" align="right" valign="top">value_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#a2a04a9d2103e27f833a9db2b6479ed5f">convert2</a> (const container_t &amp;c, const std::string &amp;parameterName)</td></tr>
<tr class="memdesc:a2a04a9d2103e27f833a9db2b6479ed5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the input value from type container_t to type value_t.  <a href="#a2a04a9d2103e27f833a9db2b6479ed5f">More...</a><br /></td></tr>
<tr class="separator:a2a04a9d2103e27f833a9db2b6479ed5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97576912e2cc15c1c5c030615e866873"><td class="memTemplParams" colspan="2">template&lt;class value_t , class container_t &gt; </td></tr>
<tr class="memitem:a97576912e2cc15c1c5c030615e866873"><td class="memTemplItemLeft" align="right" valign="top">value_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#a97576912e2cc15c1c5c030615e866873">convert2</a> (const container_t &amp;c, const std::string &amp;parameterName, const value_t &amp;defaultValue)</td></tr>
<tr class="memdesc:a97576912e2cc15c1c5c030615e866873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the input value from type container_t to type value_t.  <a href="#a97576912e2cc15c1c5c030615e866873">More...</a><br /></td></tr>
<tr class="separator:a97576912e2cc15c1c5c030615e866873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a2e0ca176506ffc8f710ce7feddb289"><td class="memTemplParams" colspan="2">template&lt;class value_t , class container_t &gt; </td></tr>
<tr class="memitem:a8a2e0ca176506ffc8f710ce7feddb289"><td class="memTemplItemLeft" align="right" valign="top">value_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#a8a2e0ca176506ffc8f710ce7feddb289">convert2</a> (const container_t &amp;c, const std::string &amp;parameterName, const value_t &amp;defaultValue, const value_t &amp;errorValue)</td></tr>
<tr class="memdesc:a8a2e0ca176506ffc8f710ce7feddb289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the input value from type container_t to type value_t.  <a href="#a8a2e0ca176506ffc8f710ce7feddb289">More...</a><br /></td></tr>
<tr class="separator:a8a2e0ca176506ffc8f710ce7feddb289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Diagnostics</div></td></tr>
<tr class="memitem:a762bc2c90a392079f9f5f3f429d24d0f"><td class="memItemLeft" align="right" valign="top"><a id="a762bc2c90a392079f9f5f3f429d24d0f"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#a762bc2c90a392079f9f5f3f429d24d0f">boostVersion</a> ()</td></tr>
<tr class="memdesc:a762bc2c90a392079f9f5f3f429d24d0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Boost version number as a string. <br /></td></tr>
<tr class="separator:a762bc2c90a392079f9f5f3f429d24d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ab02045a4b2a3c32ff68afbbd37a2c"><td class="memItemLeft" align="right" valign="top"><a id="af8ab02045a4b2a3c32ff68afbbd37a2c"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#af8ab02045a4b2a3c32ff68afbbd37a2c">version</a> ()</td></tr>
<tr class="memdesc:af8ab02045a4b2a3c32ff68afbbd37a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="namespace_object_handler.html" title="ObjectHandler. ">ObjectHandler</a> version number as a string. <br /></td></tr>
<tr class="separator:af8ab02045a4b2a3c32ff68afbbd37a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Logging</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions wrap calls to the <a class="el" href="class_object_handler_1_1_logger.html" title="Wrapper for the logging framework. ">Logger</a> class simplifying the syntax for the client application and alleviating the need for the client application to #include log4cxx headers. </p>
</div></td></tr>
<tr class="memitem:a9f37422f8728cde18653b22d78905389"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#a9f37422f8728cde18653b22d78905389">logSetFile</a> (const std::string &amp;logFileName, const int &amp;logLevel=4)</td></tr>
<tr class="memdesc:a9f37422f8728cde18653b22d78905389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start logging to file of given name.  <a href="#a9f37422f8728cde18653b22d78905389">More...</a><br /></td></tr>
<tr class="separator:a9f37422f8728cde18653b22d78905389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22518aff7dd2d0a0f45b7d66ee40e53"><td class="memItemLeft" align="right" valign="top">DLL_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#ab22518aff7dd2d0a0f45b7d66ee40e53">logWriteMessage</a> (const std::string &amp;message, const int &amp;level=4)</td></tr>
<tr class="memdesc:ab22518aff7dd2d0a0f45b7d66ee40e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a message to the log file.  <a href="#ab22518aff7dd2d0a0f45b7d66ee40e53">More...</a><br /></td></tr>
<tr class="separator:ab22518aff7dd2d0a0f45b7d66ee40e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9d8061ef1b95ae3019afab7678bf7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#adc9d8061ef1b95ae3019afab7678bf7d">logSetLevel</a> (const int &amp;logLevel)</td></tr>
<tr class="memdesc:adc9d8061ef1b95ae3019afab7678bf7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the logging threshold.  <a href="#adc9d8061ef1b95ae3019afab7678bf7d">More...</a><br /></td></tr>
<tr class="separator:adc9d8061ef1b95ae3019afab7678bf7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac4f6f3f623355c21b247a04a0f1f5f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#aac4f6f3f623355c21b247a04a0f1f5f7">logSetConsole</a> (const int &amp;console=0, const int &amp;logLevel=4)</td></tr>
<tr class="memdesc:aac4f6f3f623355c21b247a04a0f1f5f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fork log messages to stdout.  <a href="#aac4f6f3f623355c21b247a04a0f1f5f7">More...</a><br /></td></tr>
<tr class="separator:aac4f6f3f623355c21b247a04a0f1f5f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af841f0073f273e43801963455980cd64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#af841f0073f273e43801963455980cd64">logObject</a> (const std::string &amp;objectID)</td></tr>
<tr class="memdesc:af841f0073f273e43801963455980cd64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write <a class="el" href="class_object_handler_1_1_object.html" title="Interface for Objects to be stored in the ObjectHandler Repository. ">Object</a> with given ID to log file.  <a href="#af841f0073f273e43801963455980cd64">More...</a><br /></td></tr>
<tr class="separator:af841f0073f273e43801963455980cd64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc4a7c629a85503608c1aca72fa1f04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#a1fc4a7c629a85503608c1aca72fa1f04">logAllObjects</a> ()</td></tr>
<tr class="memdesc:a1fc4a7c629a85503608c1aca72fa1f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all Objects to the log file.  <a href="#a1fc4a7c629a85503608c1aca72fa1f04">More...</a><br /></td></tr>
<tr class="separator:a1fc4a7c629a85503608c1aca72fa1f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Strings</div></td></tr>
<tr class="memitem:a7e624e65e88c23d4e426ac072e327094"><td class="memItemLeft" align="right" valign="top"><a id="a7e624e65e88c23d4e426ac072e327094"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#a7e624e65e88c23d4e426ac072e327094">split</a> (const std::string &amp;line, const std::string &amp;delim, bool token_compress)</td></tr>
<tr class="memdesc:a7e624e65e88c23d4e426ac072e327094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string into substrings using the given delimiter. <br /></td></tr>
<tr class="separator:a7e624e65e88c23d4e426ac072e327094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7a495069d8bbb030152a15900d80eb"><td class="memItemLeft" align="right" valign="top"><a id="aca7a495069d8bbb030152a15900d80eb"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#aca7a495069d8bbb030152a15900d80eb">concatenate</a> (const std::vector&lt; std::string &gt; &amp;symbols, const std::string &amp;delim)</td></tr>
<tr class="memdesc:aca7a495069d8bbb030152a15900d80eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate substrings into a single string using the given delimiter. <br /></td></tr>
<tr class="separator:aca7a495069d8bbb030152a15900d80eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242a58dde7b23f1a6af183c0d64c3a30"><td class="memItemLeft" align="right" valign="top"><a id="a242a58dde7b23f1a6af183c0d64c3a30"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isNumeric</b> (const std::string &amp;s)</td></tr>
<tr class="separator:a242a58dde7b23f1a6af183c0d64c3a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Time</div></td></tr>
<tr class="memitem:a365f2e451e23553ee34f123b7ff48d2f"><td class="memItemLeft" align="right" valign="top"><a id="a365f2e451e23553ee34f123b7ff48d2f"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#a365f2e451e23553ee34f123b7ff48d2f">getTime</a> ()</td></tr>
<tr class="memdesc:a365f2e451e23553ee34f123b7ff48d2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the current time as a number. <br /></td></tr>
<tr class="separator:a365f2e451e23553ee34f123b7ff48d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2764e8981114ea0c4b6ccc73fce0e5"><td class="memItemLeft" align="right" valign="top"><a id="a1c2764e8981114ea0c4b6ccc73fce0e5"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#a1c2764e8981114ea0c4b6ccc73fce0e5">formatTime</a> (double tm)</td></tr>
<tr class="memdesc:a1c2764e8981114ea0c4b6ccc73fce0e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the given time as a string in format HH:MM:SS. <br /></td></tr>
<tr class="separator:a1c2764e8981114ea0c4b6ccc73fce0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">logFile and logLevel</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Miscellaneous utility functions. </p>
</div></td></tr>
<tr class="memitem:a1340479a1fb6d65ebc637294c516a501"><td class="memItemLeft" align="right" valign="top"><a id="a1340479a1fb6d65ebc637294c516a501"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_object_handler.html#a1340479a1fb6d65ebc637294c516a501">logFile</a> ()</td></tr>
<tr class="memdesc:a1340479a1fb6d65ebc637294c516a501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps function <a class="el" href="class_object_handler_1_1_singleton.html#ab9a592c3a92f574b0b30c62a674448a0" title="access to the unique instance ">Logger::instance()</a>.LogFile() <br /></td></tr>
<tr class="separator:a1340479a1fb6d65ebc637294c516a501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26d44348b58a75efa376dce9944fe71"><td class="memItemLeft" align="right" valign="top"><a id="aa26d44348b58a75efa376dce9944fe71"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>logLevel</b> ()</td></tr>
<tr class="separator:aa26d44348b58a75efa376dce9944fe71"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="namespace_object_handler.html" title="ObjectHandler. ">ObjectHandler</a>. </p>
<p>Namespace for <a class="el" href="namespace_object_handler.html" title="ObjectHandler. ">ObjectHandler</a> functionality. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a892c9f9f6c17eb74c345a4be752ceea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a892c9f9f6c17eb74c345a4be752ceea2">&#9670;&nbsp;</a></span>KeyPair</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;std::string, std::string&gt; <a class="el" href="namespace_object_handler.html#a892c9f9f6c17eb74c345a4be752ceea2">ObjectHandler::KeyPair</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A pair of strings. </p>
<p>Derived class <a class="el" href="class_object_handler_1_1_enum_pair_registry.html" title="A concrete instantiation of the Registry class, for &quot;pairs&quot;. ">EnumPairRegistry</a> instantiates base template class <a class="el" href="class_object_handler_1_1_registry.html" title="A registry of enumerated types and classes. ">Registry</a> with KeyPair instead of std::string, resulting in a structure in which enumerations are indexed by two strings instead of one. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a3de2e369a7c84be4b0fc99a6ab413ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de2e369a7c84be4b0fc99a6ab413ec9">&#9670;&nbsp;</a></span>convert2() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class value_t , class container_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">value_t ObjectHandler::convert2 </td>
          <td>(</td>
          <td class="paramtype">const container_t &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the input value from type container_t to type value_t. </p>
<p>If the attempt fails then wrap the exception with additional info and rethrow. </p>

</div>
</div>
<a id="a2a04a9d2103e27f833a9db2b6479ed5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a04a9d2103e27f833a9db2b6479ed5f">&#9670;&nbsp;</a></span>convert2() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class value_t , class container_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">value_t ObjectHandler::convert2 </td>
          <td>(</td>
          <td class="paramtype">const container_t &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>parameterName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the input value from type container_t to type value_t. </p>
<p>This override allows the caller to specify the parameter name, which makes the error message clearer in the event of an error. Otherwise this function behaves the same as the one above. </p>

</div>
</div>
<a id="a97576912e2cc15c1c5c030615e866873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97576912e2cc15c1c5c030615e866873">&#9670;&nbsp;</a></span>convert2() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class value_t , class container_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">value_t ObjectHandler::convert2 </td>
          <td>(</td>
          <td class="paramtype">const container_t &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>parameterName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_t &amp;&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the input value from type container_t to type value_t. </p>
<p>This function allows the caller to provide a default value in the event that the input is missing, which on Excel is true for inputs of type #NA. </p>

</div>
</div>
<a id="a8a2e0ca176506ffc8f710ce7feddb289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a2e0ca176506ffc8f710ce7feddb289">&#9670;&nbsp;</a></span>convert2() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class value_t , class container_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">value_t ObjectHandler::convert2 </td>
          <td>(</td>
          <td class="paramtype">const container_t &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>parameterName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_t &amp;&#160;</td>
          <td class="paramname"><em>defaultValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_t &amp;&#160;</td>
          <td class="paramname"><em>errorValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the input value from type container_t to type value_t. </p>
<p>This function allows the caller to provide an error value which will be returned in the case of an exception. This function does not throw.</p>
<p>An error may occur in two cases:</p>
<ul>
<li>If the input value has an error state. On Excel this is true for #NUM, #REF, etc. </li>
<li>If the attempted conversion throws. </li>
</ul>

</div>
</div>
<a id="a1fc4a7c629a85503608c1aca72fa1f04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fc4a7c629a85503608c1aca72fa1f04">&#9670;&nbsp;</a></span>logAllObjects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjectHandler::logAllObjects </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write all Objects to the log file. </p>
<p>Takes no action if the <a class="el" href="namespace_object_handler.html" title="ObjectHandler. ">ObjectHandler</a> repository is empty. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="example_8cpp-example.html#a14">example.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="af841f0073f273e43801963455980cd64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af841f0073f273e43801963455980cd64">&#9670;&nbsp;</a></span>logObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjectHandler::logObject </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>objectID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write <a class="el" href="class_object_handler_1_1_object.html" title="Interface for Objects to be stored in the ObjectHandler Repository. ">Object</a> with given ID to log file. </p>
<p>Writes a warning message to the log file if no <a class="el" href="class_object_handler_1_1_object.html" title="Interface for Objects to be stored in the ObjectHandler Repository. ">Object</a> is found with the given ID. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="example_8cpp-example.html#a11">example.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="aac4f6f3f623355c21b247a04a0f1f5f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac4f6f3f623355c21b247a04a0f1f5f7">&#9670;&nbsp;</a></span>logSetConsole()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjectHandler::logSetConsole </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>console</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>logLevel</em> = <code>4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fork log messages to stdout. </p>
<p>Wraps function <a class="el" href="class_object_handler_1_1_singleton.html#ab9a592c3a92f574b0b30c62a674448a0" title="access to the unique instance ">Logger::instance()</a>.setConsole().</p>
<p>This function is used in command-line environments and causes messages to appear both on the terminal and in the log file. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="example_8cpp-example.html#a9">example.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="a9f37422f8728cde18653b22d78905389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f37422f8728cde18653b22d78905389">&#9670;&nbsp;</a></span>logSetFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ObjectHandler::logSetFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>logFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>logLevel</em> = <code>4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start logging to file of given name. </p>
<p>Wraps function <a class="el" href="class_object_handler_1_1_singleton.html#ab9a592c3a92f574b0b30c62a674448a0" title="access to the unique instance ">Logger::instance()</a>.<a class="el" href="namespace_object_handler.html#a9f37422f8728cde18653b22d78905389" title="Start logging to file of given name. ">logSetFile()</a>. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="example_8cpp-example.html#a8">example.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="adc9d8061ef1b95ae3019afab7678bf7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc9d8061ef1b95ae3019afab7678bf7d">&#9670;&nbsp;</a></span>logSetLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjectHandler::logSetLevel </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>logLevel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the logging threshold. </p>
<p>Wraps function <a class="el" href="class_object_handler_1_1_singleton.html#ab9a592c3a92f574b0b30c62a674448a0" title="access to the unique instance ">Logger::instance()</a>.setLogLevel().</p>
<p>It is seldom necessary to call this function as the default logging level is suitable for most purposes. </p>

</div>
</div>
<a id="ab22518aff7dd2d0a0f45b7d66ee40e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab22518aff7dd2d0a0f45b7d66ee40e53">&#9670;&nbsp;</a></span>logWriteMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DLL_API void ObjectHandler::logWriteMessage </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>level</em> = <code>4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a message to the log file. </p>
<p>Wraps function <a class="el" href="class_object_handler_1_1_singleton.html#ab9a592c3a92f574b0b30c62a674448a0" title="access to the unique instance ">Logger::instance()</a>.logMessage(). </p>

</div>
</div>
<a id="aa0fd2f07cce26c0ebc1fc49b886a6e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0fd2f07cce26c0ebc1fc49b886a6e9f">&#9670;&nbsp;</a></span>operToMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;T&gt; &gt; ObjectHandler::operToMatrix </td>
          <td>(</td>
          <td class="paramtype">const OPER &amp;&#160;</td>
          <td class="paramname"><em>xMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>paramName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper template wrapper for operToMatrixImpl. </p>
<p>Accept an OPER as input and wrap this in class <a class="el" href="class_object_handler_1_1_convert_oper.html" title="Perform datatype conversions of OPERs. ">ConvertOper</a>. This simplifies syntax in client applications. </p>

</div>
</div>
<a id="a9375d8dc71301817d2a5b4f67653b492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9375d8dc71301817d2a5b4f67653b492">&#9670;&nbsp;</a></span>operToObjectVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LibraryClass , class ObjectClass &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;boost::shared_ptr&lt;LibraryClass&gt; &gt; ObjectHandler::operToObjectVector </td>
          <td>(</td>
          <td class="paramtype">const OPER &amp;&#160;</td>
          <td class="paramname"><em>xVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>paramName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper template wrapper for operToVectorImpl. </p>
<ul>
<li>Accept an OPER as input and wrap this in class <a class="el" href="class_object_handler_1_1_convert_oper.html" title="Perform datatype conversions of OPERs. ">ConvertOper</a> </li>
<li>Specify VariantToScalarObject as the algorithm to be used</li>
</ul>
<p>This simplifies syntax in client applications. </p>

</div>
</div>
<a id="ac54138a8b40b745c8fb13cb52faa8ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54138a8b40b745c8fb13cb52faa8ef3">&#9670;&nbsp;</a></span>operToVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; ObjectHandler::operToVector </td>
          <td>(</td>
          <td class="paramtype">const OPER &amp;&#160;</td>
          <td class="paramname"><em>xVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>paramName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper template wrapper for operToVectorImpl. </p>
<ul>
<li>Accept an OPER as input and wrap this in class <a class="el" href="class_object_handler_1_1_convert_oper.html" title="Perform datatype conversions of OPERs. ">ConvertOper</a> </li>
<li>Specify VariantToScalar as the algorithm to be used</li>
</ul>
<p>This simplifies syntax in client applications. </p>

</div>
</div>
<a id="a749fc7e3e73be55b2ef518c734ee0d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a749fc7e3e73be55b2ef518c734ee0d8a">&#9670;&nbsp;</a></span>stringToChar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DLL_API void ObjectHandler::stringToChar </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the std::string to the char*. </p>
<p>Assumes that the caller has allocated XL_MAX_STR_LEN bytes for the char *. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="addindynamic1_8cpp-example.html#a5">addindynamic1.cpp</a>, <a class="el" href="addindynamic2_8cpp-example.html#a6">addindynamic2.cpp</a>, and <a class="el" href="addinstatic_8cpp-example.html#a11">addinstatic.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="a3bbd00bac5e532993204d901a7be9f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bbd00bac5e532993204d901a7be9f8d">&#9670;&nbsp;</a></span>vectorToOper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ObjectHandler::vectorToOper </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OPER &amp;&#160;</td>
          <td class="paramname"><em>xVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper for the other vectorToOper. </p>
<p>Extracts the begin and end iterators of the input vector. </p>

</div>
</div>
<a id="a3b3eda3d2c8bf3547f23fb5b6ce2c37a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b3eda3d2c8bf3547f23fb5b6ce2c37a">&#9670;&nbsp;</a></span>vectorToOper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ObjectHandler::vectorToOper </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OPER &amp;&#160;</td>
          <td class="paramname"><em>xVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert type std::vector&lt;T&gt; to an Excel OPER. </p>
<p>The function sets the xlbitDLLFree bit. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
            </div>
            <div class='clearfix'></div>
<div id="footer">SourceForge logo copyright &#169; Open Source Technology Group<br>reposit logo <a href="http://www.reposit.be">copyright &#169; 2015 reposit Ltd Dublin</a><br>all other content <a href="license.html">copyright &#169; 2004-20015 The QuantLib Group</a></div>
        </div>
        <div class='clearfix'></div>
    </div>
    <div class='clearfix'></div>
</body>
</html>
