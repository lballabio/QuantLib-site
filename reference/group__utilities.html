<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QuantLib: Utilities</title>
<link rel="stylesheet" href="/styles/fonts.css" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="quantlibextra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://www.quantlib.org">QuantLib</a>: a free/open-source library for quantitative finance
   <div id="projectnumber">Reference manual - version 1.26</div>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Utilities</div></div>
</div><!--header-->
<div class="contents">
<p >Iterators are meant to build a sequence on the fly from one or more other sequences, without having to allocate place for storing it. A couple of examples: suppose we have a function which calculates the average of a sequence, and that for genericity we have implemented it as a template function which takes the beginning and the end of the sequence, so that its declaration is:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div>
<div class="line"><span class="keyword">typename</span> Iterator::value_type</div>
<div class="line">average(<span class="keyword">const</span> Iterator&amp; begin, <span class="keyword">const</span> Iterator&amp; end)</div>
</div><!-- fragment --><p >This kind of genericity allows one to use the same function to calculate the average of a std::vector, a std::list, a QuantLib::History, any other container, of a subset of any of the former.</p>
<p >Now let's say we have two sequences of numbers, and we want to calculate the average of their products. One approach could be to store the products in another sequence, and to calculate the average of the latter, as in:</p>
<div class="fragment"><div class="line"><span class="comment">// we have sequence1 and sequence2 and assume equal size:</span></div>
<div class="line"><span class="comment">// first we store their product in a vector...</span></div>
<div class="line">std::vector&lt;double&gt; products;</div>
<div class="line">std::transform(sequence1.begin(),sequence1.end(), <span class="comment">// first sequence</span></div>
<div class="line">               sequence2.begin(),                 <span class="comment">// second sequence</span></div>
<div class="line">               std::back_inserter(products),      <span class="comment">// output</span></div>
<div class="line">               std::multiplies&lt;double&gt;());        <span class="comment">// operation to perform</span></div>
<div class="line"><span class="comment">// ...then we calculate the average</span></div>
<div class="line"><span class="keywordtype">double</span> result = average(products.begin(),products.end());</div>
</div><!-- fragment --><p >The above works, however, it might be not particularly efficient since we have to allocate the product vector, quite possibly just to throw it away when the calculation is done.</p>
<p >QuantLib::coupling_iterator allows us to do the same thing without allocating the extra vector: what we do is simply:</p>
<div class="fragment"><div class="line"><span class="comment">// we have sequence1 and sequence2 and assume equal size:</span></div>
<div class="line"><span class="keywordtype">double</span> result = average(</div>
<div class="line">    make_coupling_iterator(sequence1.begin(),</div>
<div class="line">                           sequence2.begin(),</div>
<div class="line">                           std::multiplies&lt;<span class="keywordtype">double</span>()),</div>
<div class="line">    make_coupling_iterator(sequence1.end(),</div>
<div class="line">                           sequence2.end(),</div>
<div class="line">                           std::multiplies&lt;<span class="keywordtype">double</span>()));</div>
</div><!-- fragment --><p >The call to make_coupling_iterator creates an iterator which is really a reference to the two iterators and the operation we passed. Dereferencing such iterator returns the result of applying such operation to the values pointed to by the two contained iterators. Advancing the coupling iterator advances the two underlying ones. One can see how iterating on such iterator generates the products one by one so that they can be processed by <code>average()</code>, but does not need allocating memory for storing the results. The product sequence is generated on the fly.</p>
<p >The other iterators share the same principle but have different functionalities:</p><ul>
<li>combining_iterator is the same as coupling_iterator, but works on \( N \) sequences while the latter works on 2;</li>
<li>filtering_iterator generates the elements of a given sequence which satisfy a given predicate, i.e., it takes a sequence \( [x_0,x_1,\dots] \) and a predicate \( p \) and generates the sequence of those \( x_i \) for which \( p(x_i) \) returns <code>true</code>;</li>
<li>processing_iterator takes a sequence \( [x_0,x_1,\dots] \) and a function \( f \) and generates the sequence \( [f(x_0),f(x_1),\dots] \);</li>
<li>stepping_iterator takes a sequence \( [x_0,x_1,\dots] \) and a step \( m \) and generates the sequence \( [x_0,x_m,x_{2m},\dots] \) </li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by <a href="http://www.doxygen.org/index.html">Doxygen</a>
1.9.3
</small></address>
</body>
</html>
