<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QuantLib: LatentModel&lt; copulaPolicyImpl &gt; Class Template Reference</title>
<link rel="stylesheet" href="/styles/fonts.css" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="quantlibextra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://www.quantlib.org">QuantLib</a>: a free/open-source library for quantitative finance
   <div id="projectnumber">Reference manual - version 1.27.1</div>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_quant_lib.html">QuantLib</a></li><li class="navelem"><a class="el" href="class_quant_lib_1_1_latent_model.html">LatentModel</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="class_quant_lib_1_1_latent_model-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">LatentModel&lt; copulaPolicyImpl &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Generic multifactor latent variable model.  
 <a href="class_quant_lib_1_1_latent_model.html#details">More...</a></p>

<p><code>#include &lt;ql/experimental/math/latentmodel.hpp&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for LatentModel&lt; copulaPolicyImpl &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="class_quant_lib_1_1_latent_model__inherit__graph.png" border="0" usemap="#a_latent_model_3_01copula_policy_impl_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="a_latent_model_3_01copula_policy_impl_01_4_inherit__map" id="a_latent_model_3_01copula_policy_impl_01_4_inherit__map">
<area shape="rect" title="Generic multifactor latent variable model." alt="" coords="5,80,184,121"/>
<area shape="rect" href="class_quant_lib_1_1_observer.html" title="Object that gets notified when a given observable changes." alt="" coords="5,5,80,32"/>
<area shape="rect" href="class_quant_lib_1_1_observable.html" title="Object that notifies its changes to a set of observers." alt="" coords="104,5,192,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_quant_lib_1_1_latent_model_1_1_factor_sampler.html">FactorSampler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Latent model direct integration facility.</div></td></tr>
<tr class="memitem:a44137bb65de2396875934e48a6ee5099"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_quant_lib_1_1_latent_model.html#a44137bb65de2396875934e48a6ee5099">update</a> () override</td></tr>
<tr class="separator:a44137bb65de2396875934e48a6ee5099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Latent model random factor number generator facility.</div></td></tr>
<tr class="memitem:acce0ab2cacc475b2434f24c65c91685a"><td class="memItemLeft" align="right" valign="top"><a id="acce0ab2cacc475b2434f24c65c91685a" name="acce0ab2cacc475b2434f24c65c91685a"></a>
<a class="el" href="group__types.html#gaf38bdb4c54463b1f456655efa95b5c77">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const</td></tr>
<tr class="separator:acce0ab2cacc475b2434f24c65c91685a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56abc887c13cbde93385f6875e849541"><td class="memItemLeft" align="right" valign="top"><a id="a56abc887c13cbde93385f6875e849541" name="a56abc887c13cbde93385f6875e849541"></a>
<a class="el" href="group__types.html#gaf38bdb4c54463b1f456655efa95b5c77">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><b>numFactors</b> () const</td></tr>
<tr class="memdesc:a56abc887c13cbde93385f6875e849541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of systemic factors. <br /></td></tr>
<tr class="separator:a56abc887c13cbde93385f6875e849541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c9998bd5485693575f044342216cdc"><td class="memItemLeft" align="right" valign="top"><a id="ac9c9998bd5485693575f044342216cdc" name="ac9c9998bd5485693575f044342216cdc"></a>
<a class="el" href="group__types.html#gaf38bdb4c54463b1f456655efa95b5c77">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><b>numTotalFactors</b> () const</td></tr>
<tr class="memdesc:ac9c9998bd5485693575f044342216cdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of total free random factors; systemic and idiosyncratic. <br /></td></tr>
<tr class="separator:ac9c9998bd5485693575f044342216cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ed5d88e196cc3c54f7793f8196fbb4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_quant_lib_1_1_latent_model.html#ae4ed5d88e196cc3c54f7793f8196fbb4">LatentModel</a> (const std::vector&lt; std::vector&lt; <a class="el" href="group__types.html#ga4bdf4bfe76b9ffa6fa64c47d8bfa0c78">Real</a> &gt; &gt; &amp;factorsWeights, const typename copulaType::initTraits &amp;ini=copulaType::initTraits())</td></tr>
<tr class="separator:ae4ed5d88e196cc3c54f7793f8196fbb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3447b3892833206298d351755afc1e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_quant_lib_1_1_latent_model.html#abe3447b3892833206298d351755afc1e">LatentModel</a> (const std::vector&lt; <a class="el" href="group__types.html#ga4bdf4bfe76b9ffa6fa64c47d8bfa0c78">Real</a> &gt; &amp;factorsWeight, const typename copulaType::initTraits &amp;ini=copulaType::initTraits())</td></tr>
<tr class="separator:abe3447b3892833206298d351755afc1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abafaa85a02d48b40e33125881e5cd57d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_quant_lib_1_1_latent_model.html#abafaa85a02d48b40e33125881e5cd57d">LatentModel</a> (<a class="el" href="group__types.html#ga4bdf4bfe76b9ffa6fa64c47d8bfa0c78">Real</a> correlSqr, <a class="el" href="group__types.html#gaf38bdb4c54463b1f456655efa95b5c77">Size</a> nVariables, const typename copulaType::initTraits &amp;ini=copulaType::initTraits())</td></tr>
<tr class="separator:abafaa85a02d48b40e33125881e5cd57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a167de0197f4aa9da234d78f844902aeb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_quant_lib_1_1_latent_model.html#a167de0197f4aa9da234d78f844902aeb">LatentModel</a> (const <a class="el" href="class_quant_lib_1_1_handle.html">Handle</a>&lt; <a class="el" href="class_quant_lib_1_1_quote.html">Quote</a> &gt; &amp;singleFactorCorrel, <a class="el" href="group__types.html#gaf38bdb4c54463b1f456655efa95b5c77">Size</a> nVariables, const typename copulaType::initTraits &amp;ini=copulaType::initTraits())</td></tr>
<tr class="separator:a167de0197f4aa9da234d78f844902aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49ca4d6e7932d12c415e9d1dd2b2414"><td class="memItemLeft" align="right" valign="top"><a id="ac49ca4d6e7932d12c415e9d1dd2b2414" name="ac49ca4d6e7932d12c415e9d1dd2b2414"></a>
const std::vector&lt; std::vector&lt; <a class="el" href="group__types.html#ga4bdf4bfe76b9ffa6fa64c47d8bfa0c78">Real</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>factorWeights</b> () const</td></tr>
<tr class="memdesc:ac49ca4d6e7932d12c415e9d1dd2b2414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides values of the factors \( a_{i,k} \). <br /></td></tr>
<tr class="separator:ac49ca4d6e7932d12c415e9d1dd2b2414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48dd7f6484914d9c9c8667ab1ceadd29"><td class="memItemLeft" align="right" valign="top"><a id="a48dd7f6484914d9c9c8667ab1ceadd29" name="a48dd7f6484914d9c9c8667ab1ceadd29"></a>
const std::vector&lt; <a class="el" href="group__types.html#ga4bdf4bfe76b9ffa6fa64c47d8bfa0c78">Real</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>idiosyncFctrs</b> () const</td></tr>
<tr class="memdesc:a48dd7f6484914d9c9c8667ab1ceadd29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides values of the normalized idiosyncratic factors \( Z_i \). <br /></td></tr>
<tr class="separator:a48dd7f6484914d9c9c8667ab1ceadd29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31dc4b961ba8016810704c496e14079c"><td class="memItemLeft" align="right" valign="top"><a id="a31dc4b961ba8016810704c496e14079c" name="a31dc4b961ba8016810704c496e14079c"></a>
<a class="el" href="group__types.html#ga4bdf4bfe76b9ffa6fa64c47d8bfa0c78">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>latentVariableCorrel</b> (<a class="el" href="group__types.html#gaf38bdb4c54463b1f456655efa95b5c77">Size</a> iVar1, <a class="el" href="group__types.html#gaf38bdb4c54463b1f456655efa95b5c77">Size</a> iVar2) const</td></tr>
<tr class="memdesc:a31dc4b961ba8016810704c496e14079c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Latent variable correlations: <br /></td></tr>
<tr class="separator:a31dc4b961ba8016810704c496e14079c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_quant_lib_1_1_observer"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_quant_lib_1_1_observer')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_quant_lib_1_1_observer.html">Observer</a></td></tr>
<tr class="memitem:af6a9d3ca0b7f388f3b7ccb1eccf11f63 inherit pub_methods_class_quant_lib_1_1_observer"><td class="memItemLeft" align="right" valign="top"><a id="af6a9d3ca0b7f388f3b7ccb1eccf11f63" name="af6a9d3ca0b7f388f3b7ccb1eccf11f63"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Observer</b> (const <a class="el" href="class_quant_lib_1_1_observer.html">Observer</a> &amp;)</td></tr>
<tr class="separator:af6a9d3ca0b7f388f3b7ccb1eccf11f63 inherit pub_methods_class_quant_lib_1_1_observer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6810b3645967da11d5f5d4804d37bacc inherit pub_methods_class_quant_lib_1_1_observer"><td class="memItemLeft" align="right" valign="top"><a id="a6810b3645967da11d5f5d4804d37bacc" name="a6810b3645967da11d5f5d4804d37bacc"></a>
<a class="el" href="class_quant_lib_1_1_observer.html">Observer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_quant_lib_1_1_observer.html">Observer</a> &amp;)</td></tr>
<tr class="separator:a6810b3645967da11d5f5d4804d37bacc inherit pub_methods_class_quant_lib_1_1_observer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ade205ed506bf712da2704f80a73a0 inherit pub_methods_class_quant_lib_1_1_observer"><td class="memItemLeft" align="right" valign="top"><a id="aa6ade205ed506bf712da2704f80a73a0" name="aa6ade205ed506bf712da2704f80a73a0"></a>
std::pair&lt; iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>registerWith</b> (const ext::shared_ptr&lt; <a class="el" href="class_quant_lib_1_1_observable.html">Observable</a> &gt; &amp;)</td></tr>
<tr class="separator:aa6ade205ed506bf712da2704f80a73a0 inherit pub_methods_class_quant_lib_1_1_observer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d57eb97a3a57312a47bda29235f182 inherit pub_methods_class_quant_lib_1_1_observer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_quant_lib_1_1_observer.html#a51d57eb97a3a57312a47bda29235f182">registerWithObservables</a> (const ext::shared_ptr&lt; <a class="el" href="class_quant_lib_1_1_observer.html">Observer</a> &gt; &amp;)</td></tr>
<tr class="separator:a51d57eb97a3a57312a47bda29235f182 inherit pub_methods_class_quant_lib_1_1_observer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce7359ad0f73a54dba555be24855804 inherit pub_methods_class_quant_lib_1_1_observer"><td class="memItemLeft" align="right" valign="top"><a id="a4ce7359ad0f73a54dba555be24855804" name="a4ce7359ad0f73a54dba555be24855804"></a>
<a class="el" href="group__types.html#gaf38bdb4c54463b1f456655efa95b5c77">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><b>unregisterWith</b> (const ext::shared_ptr&lt; <a class="el" href="class_quant_lib_1_1_observable.html">Observable</a> &gt; &amp;)</td></tr>
<tr class="separator:a4ce7359ad0f73a54dba555be24855804 inherit pub_methods_class_quant_lib_1_1_observer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c19cb502f3b720b99b176ea6cc7e319 inherit pub_methods_class_quant_lib_1_1_observer"><td class="memItemLeft" align="right" valign="top"><a id="a0c19cb502f3b720b99b176ea6cc7e319" name="a0c19cb502f3b720b99b176ea6cc7e319"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unregisterWithAll</b> ()</td></tr>
<tr class="separator:a0c19cb502f3b720b99b176ea6cc7e319 inherit pub_methods_class_quant_lib_1_1_observer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b02345a8a15d3c5ea2844a2253f510 inherit pub_methods_class_quant_lib_1_1_observer"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_quant_lib_1_1_observer.html#a99b02345a8a15d3c5ea2844a2253f510">update</a> ()=0</td></tr>
<tr class="separator:a99b02345a8a15d3c5ea2844a2253f510 inherit pub_methods_class_quant_lib_1_1_observer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d53f9669c128dadc74a5d044a7c8e68 inherit pub_methods_class_quant_lib_1_1_observer"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_quant_lib_1_1_observer.html#a3d53f9669c128dadc74a5d044a7c8e68">deepUpdate</a> ()</td></tr>
<tr class="separator:a3d53f9669c128dadc74a5d044a7c8e68 inherit pub_methods_class_quant_lib_1_1_observer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_quant_lib_1_1_observable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_quant_lib_1_1_observable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_quant_lib_1_1_observable.html">Observable</a></td></tr>
<tr class="memitem:a840dd96e33a304cbf681d357de7f48d0 inherit pub_methods_class_quant_lib_1_1_observable"><td class="memItemLeft" align="right" valign="top"><a id="a840dd96e33a304cbf681d357de7f48d0" name="a840dd96e33a304cbf681d357de7f48d0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Observable</b> (const <a class="el" href="class_quant_lib_1_1_observable.html">Observable</a> &amp;)</td></tr>
<tr class="separator:a840dd96e33a304cbf681d357de7f48d0 inherit pub_methods_class_quant_lib_1_1_observable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522aacdd0f2408fe5e46527a6db999b4 inherit pub_methods_class_quant_lib_1_1_observable"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_quant_lib_1_1_observable.html">Observable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_quant_lib_1_1_observable.html#a522aacdd0f2408fe5e46527a6db999b4">operator=</a> (const <a class="el" href="class_quant_lib_1_1_observable.html">Observable</a> &amp;)</td></tr>
<tr class="separator:a522aacdd0f2408fe5e46527a6db999b4 inherit pub_methods_class_quant_lib_1_1_observable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397546715bfc5aedd1d16dd202a19d4c inherit pub_methods_class_quant_lib_1_1_observable"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_quant_lib_1_1_observable.html#a397546715bfc5aedd1d16dd202a19d4c">notifyObservers</a> ()</td></tr>
<tr class="separator:a397546715bfc5aedd1d16dd202a19d4c inherit pub_methods_class_quant_lib_1_1_observable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Copula interface.</h2></td></tr>
<tr class="memitem:ac175647caaabf0dae2f44633ce56cdcf"><td class="memItemLeft" align="right" valign="top"><a id="ac175647caaabf0dae2f44633ce56cdcf" name="ac175647caaabf0dae2f44633ce56cdcf"></a>
typedef copulaPolicyImpl&#160;</td><td class="memItemRight" valign="bottom"><b>copulaType</b></td></tr>
<tr class="separator:ac175647caaabf0dae2f44633ce56cdcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2172a86cee3a6b5e87ef6804283d9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#gad9817a6a21dfcb91429f0152c99d6313">Probability</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_quant_lib_1_1_latent_model.html#a9d2172a86cee3a6b5e87ef6804283d9a">cumulativeY</a> (<a class="el" href="group__types.html#ga4bdf4bfe76b9ffa6fa64c47d8bfa0c78">Real</a> val, <a class="el" href="group__types.html#gaf38bdb4c54463b1f456655efa95b5c77">Size</a> iVariable) const</td></tr>
<tr class="separator:a9d2172a86cee3a6b5e87ef6804283d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42e8a3a9fe28bd7cbb0144e1fde4e98"><td class="memItemLeft" align="right" valign="top"><a id="ac42e8a3a9fe28bd7cbb0144e1fde4e98" name="ac42e8a3a9fe28bd7cbb0144e1fde4e98"></a>
<a class="el" href="group__types.html#gad9817a6a21dfcb91429f0152c99d6313">Probability</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cumulativeZ</b> (<a class="el" href="group__types.html#ga4bdf4bfe76b9ffa6fa64c47d8bfa0c78">Real</a> z) const</td></tr>
<tr class="memdesc:ac42e8a3a9fe28bd7cbb0144e1fde4e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cumulative distribution of Z, the idiosyncratic/error factors. <br /></td></tr>
<tr class="separator:ac42e8a3a9fe28bd7cbb0144e1fde4e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6a9e92d606e0b463736794cc2415b8"><td class="memItemLeft" align="right" valign="top"><a id="a7a6a9e92d606e0b463736794cc2415b8" name="a7a6a9e92d606e0b463736794cc2415b8"></a>
<a class="el" href="group__types.html#gad9817a6a21dfcb91429f0152c99d6313">Probability</a>&#160;</td><td class="memItemRight" valign="bottom"><b>density</b> (const std::vector&lt; <a class="el" href="group__types.html#ga4bdf4bfe76b9ffa6fa64c47d8bfa0c78">Real</a> &gt; &amp;m) const</td></tr>
<tr class="memdesc:a7a6a9e92d606e0b463736794cc2415b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Density function of M, the market/systemic factors. <br /></td></tr>
<tr class="separator:a7a6a9e92d606e0b463736794cc2415b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54052fb0c8917e0d63d6d52230e3b59a"><td class="memItemLeft" align="right" valign="top"><a id="a54052fb0c8917e0d63d6d52230e3b59a" name="a54052fb0c8917e0d63d6d52230e3b59a"></a>
<a class="el" href="group__types.html#ga4bdf4bfe76b9ffa6fa64c47d8bfa0c78">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>inverseCumulativeDensity</b> (<a class="el" href="group__types.html#gad9817a6a21dfcb91429f0152c99d6313">Probability</a> p, <a class="el" href="group__types.html#gaf38bdb4c54463b1f456655efa95b5c77">Size</a> iFactor) const</td></tr>
<tr class="memdesc:a54052fb0c8917e0d63d6d52230e3b59a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse cumulative distribution of the systemic factor iFactor. <br /></td></tr>
<tr class="separator:a54052fb0c8917e0d63d6d52230e3b59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e205d1cabb02b58e65e4f1ee08658f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga4bdf4bfe76b9ffa6fa64c47d8bfa0c78">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_quant_lib_1_1_latent_model.html#a36e205d1cabb02b58e65e4f1ee08658f">inverseCumulativeY</a> (<a class="el" href="group__types.html#gad9817a6a21dfcb91429f0152c99d6313">Probability</a> p, <a class="el" href="group__types.html#gaf38bdb4c54463b1f456655efa95b5c77">Size</a> iVariable) const</td></tr>
<tr class="separator:a36e205d1cabb02b58e65e4f1ee08658f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5b1879390c62bbddd5f61deb20b49e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga4bdf4bfe76b9ffa6fa64c47d8bfa0c78">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_quant_lib_1_1_latent_model.html#acd5b1879390c62bbddd5f61deb20b49e">inverseCumulativeZ</a> (<a class="el" href="group__types.html#gad9817a6a21dfcb91429f0152c99d6313">Probability</a> p) const</td></tr>
<tr class="separator:acd5b1879390c62bbddd5f61deb20b49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ddec7b4cf6bfa12f69851be69c942ca"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__types.html#ga4bdf4bfe76b9ffa6fa64c47d8bfa0c78">Real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_quant_lib_1_1_latent_model.html#a9ddec7b4cf6bfa12f69851be69c942ca">allFactorCumulInverter</a> (const std::vector&lt; <a class="el" href="group__types.html#ga4bdf4bfe76b9ffa6fa64c47d8bfa0c78">Real</a> &gt; &amp;probs) const</td></tr>
<tr class="separator:a9ddec7b4cf6bfa12f69851be69c942ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd0aa599a5b42688ff1ca2bd4cf9d3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga4bdf4bfe76b9ffa6fa64c47d8bfa0c78">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_quant_lib_1_1_latent_model.html#a0dd0aa599a5b42688ff1ca2bd4cf9d3f">latentVarValue</a> (const std::vector&lt; <a class="el" href="group__types.html#ga4bdf4bfe76b9ffa6fa64c47d8bfa0c78">Real</a> &gt; &amp;allFactors, <a class="el" href="group__types.html#gaf38bdb4c54463b1f456655efa95b5c77">Size</a> iVar) const</td></tr>
<tr class="separator:a0dd0aa599a5b42688ff1ca2bd4cf9d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a550f5b48aa163387e0dc3a9f00996a7f"><td class="memItemLeft" align="right" valign="top"><a id="a550f5b48aa163387e0dc3a9f00996a7f" name="a550f5b48aa163387e0dc3a9f00996a7f"></a>
const copulaType &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>copula</b> () const</td></tr>
<tr class="separator:a550f5b48aa163387e0dc3a9f00996a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Integration facility interface</h2></td></tr>
<tr class="memitem:a3769373e685b70bb91c38bd895b886fd"><td class="memItemLeft" align="right" valign="top"><a id="a3769373e685b70bb91c38bd895b886fd" name="a3769373e685b70bb91c38bd895b886fd"></a>
std::vector&lt; std::vector&lt; <a class="el" href="group__types.html#ga4bdf4bfe76b9ffa6fa64c47d8bfa0c78">Real</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>factorWeights_</b></td></tr>
<tr class="separator:a3769373e685b70bb91c38bd895b886fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd506ff5fd9bbb04b51f783220ed2a9"><td class="memItemLeft" align="right" valign="top"><a id="a0dd506ff5fd9bbb04b51f783220ed2a9" name="a0dd506ff5fd9bbb04b51f783220ed2a9"></a>
<a class="el" href="class_quant_lib_1_1_handle.html">Handle</a>&lt; <a class="el" href="class_quant_lib_1_1_quote.html">Quote</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>cachedMktFactor_</b></td></tr>
<tr class="separator:a0dd506ff5fd9bbb04b51f783220ed2a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c951ff85d3dfed2174ab47d1808351"><td class="memItemLeft" align="right" valign="top"><a id="ab8c951ff85d3dfed2174ab47d1808351" name="ab8c951ff85d3dfed2174ab47d1808351"></a>
std::vector&lt; <a class="el" href="group__types.html#ga4bdf4bfe76b9ffa6fa64c47d8bfa0c78">Real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>idiosyncFctrs_</b></td></tr>
<tr class="separator:ab8c951ff85d3dfed2174ab47d1808351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8639907820775808810c8a525d5bdd8"><td class="memItemLeft" align="right" valign="top"><a id="ad8639907820775808810c8a525d5bdd8" name="ad8639907820775808810c8a525d5bdd8"></a>
<a class="el" href="group__types.html#gaf38bdb4c54463b1f456655efa95b5c77">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><b>nFactors_</b></td></tr>
<tr class="memdesc:ad8639907820775808810c8a525d5bdd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of systemic factors. <br /></td></tr>
<tr class="separator:ad8639907820775808810c8a525d5bdd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44fb9cd28ad962ce4f8e1fa2d91e1147"><td class="memItemLeft" align="right" valign="top"><a id="a44fb9cd28ad962ce4f8e1fa2d91e1147" name="a44fb9cd28ad962ce4f8e1fa2d91e1147"></a>
<a class="el" href="group__types.html#gaf38bdb4c54463b1f456655efa95b5c77">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><b>nVariables_</b></td></tr>
<tr class="memdesc:a44fb9cd28ad962ce4f8e1fa2d91e1147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of latent model variables, idiosyncratic terms or model dim. <br /></td></tr>
<tr class="separator:a44fb9cd28ad962ce4f8e1fa2d91e1147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af660dddb75bc7b39f47bf1e38b5916bd"><td class="memItemLeft" align="right" valign="top"><a id="af660dddb75bc7b39f47bf1e38b5916bd" name="af660dddb75bc7b39f47bf1e38b5916bd"></a>
copulaType&#160;</td><td class="memItemRight" valign="bottom"><b>copula_</b></td></tr>
<tr class="separator:af660dddb75bc7b39f47bf1e38b5916bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada44c6f03858c0d5f260c1815cc22246"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__types.html#ga4bdf4bfe76b9ffa6fa64c47d8bfa0c78">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_quant_lib_1_1_latent_model.html#ada44c6f03858c0d5f260c1815cc22246">integratedExpectedValue</a> (const ext::function&lt; <a class="el" href="group__types.html#ga4bdf4bfe76b9ffa6fa64c47d8bfa0c78">Real</a>(const std::vector&lt; <a class="el" href="group__types.html#ga4bdf4bfe76b9ffa6fa64c47d8bfa0c78">Real</a> &gt; &amp;v1)&gt; &amp;f) const</td></tr>
<tr class="separator:ada44c6f03858c0d5f260c1815cc22246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff996705d3c8a673161207813581e8a0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__types.html#ga4bdf4bfe76b9ffa6fa64c47d8bfa0c78">Real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_quant_lib_1_1_latent_model.html#aff996705d3c8a673161207813581e8a0">integratedExpectedValueV</a> (const ext::function&lt; std::vector&lt; <a class="el" href="group__types.html#ga4bdf4bfe76b9ffa6fa64c47d8bfa0c78">Real</a> &gt;(const std::vector&lt; <a class="el" href="group__types.html#ga4bdf4bfe76b9ffa6fa64c47d8bfa0c78">Real</a> &gt; &amp;v1)&gt; &amp;f) const</td></tr>
<tr class="separator:aff996705d3c8a673161207813581e8a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b7c62b871a0a1812b9d52c6689b4ef"><td class="memItemLeft" align="right" valign="top">virtual const ext::shared_ptr&lt; LMIntegration &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_quant_lib_1_1_latent_model.html#ad5b7c62b871a0a1812b9d52c6689b4ef">integration</a> () const</td></tr>
<tr class="separator:ad5b7c62b871a0a1812b9d52c6689b4ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_attribs_class_quant_lib_1_1_observer"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_class_quant_lib_1_1_observer')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="class_quant_lib_1_1_observer.html">Observer</a></td></tr>
<tr class="memitem:a460be9983010f6c71e68d745c24cb60a inherit pub_attribs_class_quant_lib_1_1_observer"><td class="memItemLeft" align="right" valign="top">QL_DEPRECATED typedef boost::unordered_set&lt; ext::shared_ptr&lt; <a class="el" href="class_quant_lib_1_1_observable.html">Observable</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_quant_lib_1_1_observer.html#a460be9983010f6c71e68d745c24cb60a">set_type</a></td></tr>
<tr class="separator:a460be9983010f6c71e68d745c24cb60a inherit pub_attribs_class_quant_lib_1_1_observer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1c39d3d73d67cae2d3cc3eb25a6fc7 inherit pub_attribs_class_quant_lib_1_1_observer"><td class="memItemLeft" align="right" valign="top"><a id="a9c1c39d3d73d67cae2d3cc3eb25a6fc7" name="a9c1c39d3d73d67cae2d3cc3eb25a6fc7"></a>
QL_DEPRECATED_DISABLE_WARNING typedef set_type::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:a9c1c39d3d73d67cae2d3cc3eb25a6fc7 inherit pub_attribs_class_quant_lib_1_1_observer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class copulaPolicyImpl&gt;<br />
class QuantLib::LatentModel&lt; copulaPolicyImpl &gt;</div><p >Generic multifactor latent variable model. </p>
<dl class="section user"><dt></dt><dd>In this model set up one considers latent (random) variables \( Y_i \) described by: <p class="formulaDsp">
\[
    \begin{array}{ccccc}
    Y_1 &amp; = &amp; \sum_k M_k a_{1,k} &amp; + \sqrt{1-\sum_k a_{1,k}^2} Z_1 &amp; 
        \sim \Phi_{Y_1}\nonumber \\
    ... &amp; = &amp;      ... &amp; ...   &amp; \nonumber \\
    Y_i &amp; = &amp; \sum_k M_k a_{i,k} &amp; + \sqrt{1-\sum_k a_{i,k}^2} Z_i &amp; 
        \sim \Phi_{Y_i}\nonumber \\
    ... &amp; = &amp;      ... &amp; ...   &amp; \nonumber \\
    Y_N &amp; = &amp; \sum_k M_k a_{N,k} &amp; + \sqrt{1-\sum_k a_{N,k}^2} Z_N &amp; 
        \sim \Phi_{Y_N}
    \end{array}
    \]
</p>
 where the systemic \( M_k \) and idiosyncratic \( Z_i \) (this last one known as error term in some contexts) random variables have independent zero-mean unit-variance distributions. A restriction of the model implemented here is that the N idiosyncratic variables all follow the same probability law \( \Phi_Z(z)\) (but they are still independent random variables) Also the model is normalized so that: \(-1\leq a_{i,k} \leq 1\) (technically the \(Y_i\) are convex linear combinations). The correlation between \(Y_i\) and \(Y_j\) is then \(\sum_k a_{i,k} a_{j,k}\). \(\Phi_{Y_i}\) denotes the cumulative distribution function of \(Y_i\) which in general differs for each latent variable.</dd></dl>
<dl class="section user"><dt></dt><dd>In its single factor set up this model is usually employed in derivative pricing and it is best to use it through integration of the desired statistical properties of the model; in its multifactorial version (with typically around a dozen factors) it is used in the context of portfolio risk metrics; because of the number of variables it is best to opt for a simulation to compute model properties/magnitudes. For this reason this class template provides a random factor sample interface and an integration interface that will be instantiated by derived concrete models as needed. The class is neutral on the integration and random generation algorithms</dd></dl>
<dl class="section user"><dt></dt><dd>The latent variables are typically treated as unobservable magnitudes and they serve to model one or several magnitudes related to them through some function <p class="formulaDsp">
\[
    \begin{array}{ccc}
    F_i(Y_i) &amp; = &amp; 
        F_i(\sum_k M_k a_{i,k} + \sqrt{1-\sum_k a_{i,k}^2} Z_i )\nonumber \\
    &amp; = &amp; F_i(M_1,..., M_k, ..., M_K, Z_i)
    \end{array}
    \]
</p>
 The transfer function can have a more generic form: \(F_i(Y_1,....,Y_N)\) but here the model is restricted to a one to one relation between the latent variables and the modelled ones. Also it is assumed that \(F_i(y_i; \tau)\) is monotonic in \(y_i\); it can then be inverted and the relation of the cumulative probability of \(F_i\) and \(Y_i\) is simple: <p class="formulaDsp">
\[
    \int_{\infty}^b \phi_{F_i} df = 
        \int_{\infty}^{F_i^{-1}(b)} \phi_{Y_i} dy
    \]
</p>
 If \(t\) is some value of the functional or modelled variable, \(y\) is mapped to \(t\) such that percentiles match, i.e. \(F_Y(y)=Q_i(t)\) or \(y=F_Y^{-1}(Q_i(t))\). The class provides an integration facility of arbitrary functions dependent on the model states. It also provides random number generation interfaces for usage of the model in monte carlo simulations.</dd></dl>
<dl class="section user"><dt></dt><dd>Now let \(\Phi_Z(z)\) be the cumulated distribution function of (all equal as mentioned) \(Z_i\). For a given realization of \(M_k\), this determines the distribution of \(y\): <p class="formulaDsp">
\[
    Prob \,(Y_i &lt; y|M_k) = \Phi_Z \left( \frac{y-\sum_k a_{i,k}\,M_k}
        {\sqrt{1-\sum_k a_{i,k}^2}}\right)
    \qquad
    \mbox{or}
    \qquad
    Prob \,(t_i &lt; t|M) = \Phi_Z \left( \frac
        {F_{Y_{i}}^{-1}(Q_i(t))-\sum_k a_{i,k}\,M_k}
        {\sqrt{1-\sum_k a_{i,k}^2}}
    \right)
    \]
</p>
 The distribution functions of \( M_k, Z_i \) are specified in specific copula template classes. The distribution function of \( Y_i \) is then given by the convolution <p class="formulaDsp">
\[
    F_{Y_{i}}(y) = Prob\,(Y_i&lt;y) = 
    \int_{-\infty}^\infty\,\cdots\,\int_{-\infty}^{\infty}\:
    D_Z(z)\,\prod_k D_{M_{k}}(m_k) \quad
    \Theta \left(y - \sum_k a_{i,k}m_k - 
        \sqrt{1-\sum_k a_{i,k}^2}\,z\right)\,d\bar{m}\,dz,
    \qquad
    \Theta (x) = \left\{
    \begin{array}{ll}
    1 &amp; x \geq 0 \\
    0 &amp; x &lt; 0
    \end{array}\right.
    \]
</p>
 where \( D_Z(z) \) and \( D_M(m) \) are the probability densities of \( Z\) and \( M, \) respectively.</dd></dl>
<dl class="section user"><dt></dt><dd>This convolution can also be written <p class="formulaDsp">
\[
    F_{Y_{i}}(y) = Prob \,(Y_i &lt; y) =
    \int_{-\infty}^\infty\,\cdots\,\int_{-\infty}^{\infty} 
        D_{M_{k}}(m_k)\,dm_k\:
    \int_{-\infty}^{g(y,\vec{a},\vec{m})} D_Z(z)\,dz, \qquad
    g(y,\vec{a},\vec{m}) = \frac{y - \sum_k a_{i,k}m_k}
        {\sqrt{1-\sum_k a_{i,k}^2}}, \qquad \sum_k a_{i,k}^2 &lt; 1
    \]
</p>
 In general, \( F_{Y_{i}}(y) \) needs to be computed numerically.</dd></dl>
<dl class="section user"><dt></dt><dd>The policy class template separates the copula function (the distributions involved) and the functionality (i.e. what the latent <br  />
 model represents: a default probability, a recovery...). Since the <br  />
 copula methods for the probabilities are to be called repeatedly from an integration or a MC simulation, virtual tables are avoided and template parameter mechnics is preferred.</dd></dl>
<dl class="section user"><dt></dt><dd>There is nothing at this level enforncing the requirement on the factor distributions to be of zero mean and unit variance. Thats the user responsibility and the model fails to behave correctly if it is not the case.</dd></dl>
<dl class="section user"><dt></dt><dd>Derived classes should implement a modelled magnitude (default time, etc) and will provide probability distributions and conditional values. They could also provide functionality for the parameter inversion problem, the (e.g.) time at which the modeled variable first takes a given value. This problem has solution/sense depending on the transfer function \(F_i(Y_i)\) characteristics.</dd></dl>
<p>To make direct integration and simulation time efficient virtual functions have been avoided in accessing methods in the copula policy and in the sampling of the random factors </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae4ed5d88e196cc3c54f7793f8196fbb4" name="ae4ed5d88e196cc3c54f7793f8196fbb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ed5d88e196cc3c54f7793f8196fbb4">&#9670;&nbsp;</a></span>LatentModel() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_quant_lib_1_1_latent_model.html">LatentModel</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="group__types.html#ga4bdf4bfe76b9ffa6fa64c47d8bfa0c78">Real</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>factorsWeights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename copulaType::initTraits &amp;&#160;</td>
          <td class="paramname"><em>ini</em> = <code>copulaType::initTraits()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Constructs a LM with an arbitrary number of latent variables and factors given by the dimensions of the passed matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factorsWeights</td><td>Ordering is factorWeights_[iVar][iFactor] </td></tr>
    <tr><td class="paramname">ini</td><td>Initialization variables. Trait type from the copula policy to allow for static policies (this solution needs to be revised, possibly drop the static policy and create a policy member in <a class="el" href="class_quant_lib_1_1_latent_model.html" title="Generic multifactor latent variable model.">LatentModel</a>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe3447b3892833206298d351755afc1e" name="abe3447b3892833206298d351755afc1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe3447b3892833206298d351755afc1e">&#9670;&nbsp;</a></span>LatentModel() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_quant_lib_1_1_latent_model.html">LatentModel</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__types.html#ga4bdf4bfe76b9ffa6fa64c47d8bfa0c78">Real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>factorsWeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename copulaType::initTraits &amp;&#160;</td>
          <td class="paramname"><em>ini</em> = <code>copulaType::initTraits()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Constructs a LM with an arbitrary number of latent variables depending only on one random factor but contributing to each latent variable through different weights. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factorsWeight</td><td>Ordering is factorWeights_[iVariable] </td></tr>
    <tr><td class="paramname">ini</td><td>Initialization variables. Trait type from the copula policy to allow for static policies (this solution needs to be revised, possibly drop the static policy and create a policy member in <a class="el" href="class_quant_lib_1_1_latent_model.html" title="Generic multifactor latent variable model.">LatentModel</a>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abafaa85a02d48b40e33125881e5cd57d" name="abafaa85a02d48b40e33125881e5cd57d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abafaa85a02d48b40e33125881e5cd57d">&#9670;&nbsp;</a></span>LatentModel() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_quant_lib_1_1_latent_model.html">LatentModel</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga4bdf4bfe76b9ffa6fa64c47d8bfa0c78">Real</a>&#160;</td>
          <td class="paramname"><em>correlSqr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#gaf38bdb4c54463b1f456655efa95b5c77">Size</a>&#160;</td>
          <td class="paramname"><em>nVariables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename copulaType::initTraits &amp;&#160;</td>
          <td class="paramname"><em>ini</em> = <code>copulaType::initTraits()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Constructs a LM with an arbitrary number of latent variables depending only on one random factor with the same weight for all latent variables.</p>
<p >correlSqr is the weight, same for all.</p>
<p >ini is a trait type from the copula policy, to allow for static policies (this solution needs to be revised, possibly drop the static policy and create a policy member in <a class="el" href="class_quant_lib_1_1_latent_model.html" title="Generic multifactor latent variable model.">LatentModel</a>) </p>

</div>
</div>
<a id="a167de0197f4aa9da234d78f844902aeb" name="a167de0197f4aa9da234d78f844902aeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a167de0197f4aa9da234d78f844902aeb">&#9670;&nbsp;</a></span>LatentModel() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_quant_lib_1_1_latent_model.html">LatentModel</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_quant_lib_1_1_handle.html">Handle</a>&lt; <a class="el" href="class_quant_lib_1_1_quote.html">Quote</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>singleFactorCorrel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#gaf38bdb4c54463b1f456655efa95b5c77">Size</a>&#160;</td>
          <td class="paramname"><em>nVariables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename copulaType::initTraits &amp;&#160;</td>
          <td class="paramname"><em>ini</em> = <code>copulaType::initTraits()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Constructs a LM with an arbitrary number of latent variables depending only on one random factor with the same weight for all latent variables. The weight is observed and this constructor is intended to be used when the model relates to a market value.</p>
<p >singleFactorCorrel is the weight/mkt-factor, same for all.</p>
<p >ini is a trait type from the copula policy, to allow for static policies (this solution needs to be revised, possibly drop the static policy and create a policy member in <a class="el" href="class_quant_lib_1_1_latent_model.html" title="Generic multifactor latent variable model.">LatentModel</a>) </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a44137bb65de2396875934e48a6ee5099" name="a44137bb65de2396875934e48a6ee5099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44137bb65de2396875934e48a6ee5099">&#9670;&nbsp;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void update </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >This method must be implemented in derived classes. An instance of Observer does not call this method directly: instead, it will be called by the observables the instance registered with when they need to notify any changes. </p>

<p>Implements <a class="el" href="class_quant_lib_1_1_observer.html#a99b02345a8a15d3c5ea2844a2253f510">Observer</a>.</p>

</div>
</div>
<a id="a9d2172a86cee3a6b5e87ef6804283d9a" name="a9d2172a86cee3a6b5e87ef6804283d9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d2172a86cee3a6b5e87ef6804283d9a">&#9670;&nbsp;</a></span>cumulativeY()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#gad9817a6a21dfcb91429f0152c99d6313">Probability</a> cumulativeY </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#ga4bdf4bfe76b9ffa6fa64c47d8bfa0c78">Real</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#gaf38bdb4c54463b1f456655efa95b5c77">Size</a>&#160;</td>
          <td class="paramname"><em>iVariable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Cumulative probability of the \( Y_i \) modelled latent random variable to take a given value. </p>

</div>
</div>
<a id="a36e205d1cabb02b58e65e4f1ee08658f" name="a36e205d1cabb02b58e65e4f1ee08658f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36e205d1cabb02b58e65e4f1ee08658f">&#9670;&nbsp;</a></span>inverseCumulativeY()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga4bdf4bfe76b9ffa6fa64c47d8bfa0c78">Real</a> inverseCumulativeY </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#gad9817a6a21dfcb91429f0152c99d6313">Probability</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#gaf38bdb4c54463b1f456655efa95b5c77">Size</a>&#160;</td>
          <td class="paramname"><em>iVariable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Inverse cumulative value of the i-th random latent variable with a given probability. </p>

</div>
</div>
<a id="acd5b1879390c62bbddd5f61deb20b49e" name="acd5b1879390c62bbddd5f61deb20b49e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd5b1879390c62bbddd5f61deb20b49e">&#9670;&nbsp;</a></span>inverseCumulativeZ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga4bdf4bfe76b9ffa6fa64c47d8bfa0c78">Real</a> inverseCumulativeZ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__types.html#gad9817a6a21dfcb91429f0152c99d6313">Probability</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Inverse cumulative value of the idiosyncratic variable with a given probability. </p>

</div>
</div>
<a id="a9ddec7b4cf6bfa12f69851be69c942ca" name="a9ddec7b4cf6bfa12f69851be69c942ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ddec7b4cf6bfa12f69851be69c942ca">&#9670;&nbsp;</a></span>allFactorCumulInverter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="group__types.html#ga4bdf4bfe76b9ffa6fa64c47d8bfa0c78">Real</a> &gt; allFactorCumulInverter </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__types.html#ga4bdf4bfe76b9ffa6fa64c47d8bfa0c78">Real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>probs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >All factor cumulative inversion. Used in integrations and sampling. Inverts all the cumulative random factors probabilities in the model. These are all the systemic factors plus all the idiosyncratic ones, so the size of the inversion is the number of systemic factors plus the number of latent modelled variables </p>

</div>
</div>
<a id="a0dd0aa599a5b42688ff1ca2bd4cf9d3f" name="a0dd0aa599a5b42688ff1ca2bd4cf9d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dd0aa599a5b42688ff1ca2bd4cf9d3f">&#9670;&nbsp;</a></span>latentVarValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga4bdf4bfe76b9ffa6fa64c47d8bfa0c78">Real</a> latentVarValue </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__types.html#ga4bdf4bfe76b9ffa6fa64c47d8bfa0c78">Real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>allFactors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__types.html#gaf38bdb4c54463b1f456655efa95b5c77">Size</a>&#160;</td>
          <td class="paramname"><em>iVar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The value of the latent variable Y_i conditional to (given) a set of values of the factors.</p>
<p >The passed allFactors vector contains values for all the independent factors in the model (systemic and idiosyncratic, in that order). A full sample is required, i.e. all the idiosyncratic values are expected to be present even if only the relevant one is used. </p>

</div>
</div>
<a id="ada44c6f03858c0d5f260c1815cc22246" name="ada44c6f03858c0d5f260c1815cc22246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada44c6f03858c0d5f260c1815cc22246">&#9670;&nbsp;</a></span>integratedExpectedValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__types.html#ga4bdf4bfe76b9ffa6fa64c47d8bfa0c78">Real</a> integratedExpectedValue </td>
          <td>(</td>
          <td class="paramtype">const ext::function&lt; <a class="el" href="group__types.html#ga4bdf4bfe76b9ffa6fa64c47d8bfa0c78">Real</a>(const std::vector&lt; <a class="el" href="group__types.html#ga4bdf4bfe76b9ffa6fa64c47d8bfa0c78">Real</a> &gt; &amp;v1)&gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Integrates an arbitrary scalar function over the density domain(i.e. computes its expected value). </p>

</div>
</div>
<a id="aff996705d3c8a673161207813581e8a0" name="aff996705d3c8a673161207813581e8a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff996705d3c8a673161207813581e8a0">&#9670;&nbsp;</a></span>integratedExpectedValueV()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="group__types.html#ga4bdf4bfe76b9ffa6fa64c47d8bfa0c78">Real</a> &gt; integratedExpectedValueV </td>
          <td>(</td>
          <td class="paramtype">const ext::function&lt; std::vector&lt; <a class="el" href="group__types.html#ga4bdf4bfe76b9ffa6fa64c47d8bfa0c78">Real</a> &gt;(const std::vector&lt; <a class="el" href="group__types.html#ga4bdf4bfe76b9ffa6fa64c47d8bfa0c78">Real</a> &gt; &amp;v1)&gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Integrates an arbitrary vector function over the density domain(i.e. computes its expected value). </p>

</div>
</div>
<a id="ad5b7c62b871a0a1812b9d52c6689b4ef" name="ad5b7c62b871a0a1812b9d52c6689b4ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5b7c62b871a0a1812b9d52c6689b4ef">&#9670;&nbsp;</a></span>integration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const ext::shared_ptr&lt; LMIntegration &gt; &amp; integration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="class_quant_lib_1_1_default_latent_model.html#a941ed89968f29e88e986144934b71274">DefaultLatentModel&lt; copulaPolicy &gt;</a>, and <a class="el" href="class_quant_lib_1_1_spot_recovery_latent_model.html#a941ed89968f29e88e986144934b71274">SpotRecoveryLatentModel&lt; copulaPolicy &gt;</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by <a href="http://www.doxygen.org/index.html">Doxygen</a>
1.9.4
</small></address>
</body>
</html>
